I just want to ask in my settings.js when I click the edit profile am I getting the profile photo, cover photo, first name, and so on. I am not sure it get is it in profile.js or in ProfileModal.js Cause the settings must already have data if it was already set in the profile right so update my settings.js. Without ruining ui and functionality of settings.js So for example the profile the first name has ron so when I click edit in settings it has first name ron already. Update my settings.js wthout ruining the ui and functionality

I will send my past 2 codes when I am not transferring yet it to modal

profile.js
import React, { useState, useCallback, useEffect } from "react";
import { View, Text, Image, StyleSheet, TouchableOpacity, ScrollView, Modal, TextInput, Platform, KeyboardAvoidingView, TouchableWithoutFeedback, Keyboard, Alert, RefreshControl, SafeAreaView, FlatList } from "react-native";
import * as ImagePicker from "expo-image-picker";
import { useFocusEffect, useRouter } from "expo-router";
import AsyncStorage from "@react-native-async-storage/async-storage";
import DateTimePicker from "@react-native-community/datetimepicker";
import Header from "../components/Header";
import Icon from "react-native-vector-icons/FontAwesome";
import { Ionicons } from '@expo/vector-icons';
import { supabase } from "../../supabase/supabaseClient";
import { useUser } from "../contexts/UserContext";
import AndroidFooterSpacer from '../components/Footer';


const API_BASE = "http://192.168.18.22:3000/api";
const API_ORIGIN = API_BASE.replace(/\/api$/, "");


export default function ProfileScreen() {
  // Get user data from UserContext
  const { userData, refreshUserData } = useUser();
  const role = userData?.role || null;
  const router = useRouter();
  
  const [modalVisible, setModalVisible] = useState(false);
  const [firstName, setFirstName] = useState("");
  const [middleName, setMiddleName] = useState("");
  const [lastName, setLastName] = useState("");
  const [userNameField, setUserNameField] = useState("");
  const [username, setUsername] = useState("");
  const [sex, setSex] = useState("");
  const [birthday, setBirthday] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [showSexDropdown, setShowSexDropdown] = useState(false);
  const [address, setAddress] = useState("");
  const [bio, setBio] = useState("");
  const [about, setAbout] = useState("");
  const [image, setImage] = useState(null);
  const [backgroundImage, setBackgroundImage] = useState(null);
  const [selectedArt, setSelectedArt] = useState(null);
  const [tempImage, setTempImage] = useState(null);
  const [tempBackgroundImage, setTempBackgroundImage] = useState(null);
  const [tempFirstName, setTempFirstName] = useState("");
  const [tempMiddleName, setTempMiddleName] = useState("");
  const [tempLastName, setTempLastName] = useState("");
  const [tempUserNameField, setTempUserNameField] = useState("");
  const [tempSex, setTempSex] = useState("");
  const [tempBirthday, setTempBirthday] = useState(new Date());
  const [tempAddress, setTempAddress] = useState("");
  const [tempBio, setTempBio] = useState("");
  const [tempAbout, setTempAbout] = useState("");
  const [accessToken, setAccessToken] = useState(null);
  const [refreshToken, setRefreshToken] = useState(null);
  const [galleryImages, setGalleryImages] = useState([]);
  
  // Artwork upload modal state
  const [artModalVisible, setArtModalVisible] = useState(false);
  const [artImage, setArtImage] = useState(null); // { uri }
  const [artTitle, setArtTitle] = useState("");
  const [artDescription, setArtDescription] = useState("");
  const [artMedium, setArtMedium] = useState("");
  const [artUploading, setArtUploading] = useState(false);
  const [artApplyWatermark, setArtApplyWatermark] = useState(true);
  const [artWatermarkText, setArtWatermarkText] = useState("");
  // Artwork interactions
  const [artComments, setArtComments] = useState([]);
  const [artLikesCount, setArtLikesCount] = useState(0);
  const [artUserLiked, setArtUserLiked] = useState(false);
  const [artNewComment, setArtNewComment] = useState("");
  const [descriptionExpanded, setDescriptionExpanded] = useState(false);
  const [refreshing, setRefreshing] = useState(false);

  // Edit artwork modal state
  const [editModalVisible, setEditModalVisible] = useState(false);
  const [editingArt, setEditingArt] = useState(null);
  const [editArtImage, setEditArtImage] = useState(null);
  const [editArtTitle, setEditArtTitle] = useState("");
  const [editArtDescription, setEditArtDescription] = useState("");
  const [editArtMedium, setEditArtMedium] = useState("");
  const [editArtUploading, setEditArtUploading] = useState(false);

  // Comments modal state
  const [commentsModalVisible, setCommentsModalVisible] = useState(false);
  const [commentingArt, setCommentingArt] = useState(null); // Store which art we're commenting on
  const [artMenuVisible, setArtMenuVisible] = useState(false); // For artwork edit/delete menu
  const [commentMenuForId, setCommentMenuForId] = useState(null);
  const [editingCommentId, setEditingCommentId] = useState(null);
  const [editCommentText, setEditCommentText] = useState('');
  const [commentPage, setCommentPage] = useState(1);
  const [hasMoreComments, setHasMoreComments] = useState(false);
  const [loadingMoreComments, setLoadingMoreComments] = useState(false);
  const [totalCommentCount, setTotalCommentCount] = useState(0);
  const [currentUserId, setCurrentUserId] = useState(null);
  
  // Open comments modal - close artwork modal first
  const openCommentsModal = async () => {
    console.log('[profile] Opening comments modal, selectedArt:', selectedArt?.id);
    setCommentingArt(selectedArt); // Save the artwork
    setSelectedArt(null); // Close artwork modal
    setCommentsModalVisible(true); // Open comments modal
    if (selectedArt?.id) {
      await fetchArtComments(selectedArt.id);
    }
  };
  
  // Close comments modal and go back to artwork
  const closeCommentsModal = () => {
    setCommentsModalVisible(false);
    setSelectedArt(commentingArt); // Reopen artwork modal
    setCommentingArt(null);
  };

  // Apply as Artist modal state
  const [applyModalVisible, setApplyModalVisible] = useState(false);
  const [appFirstName, setAppFirstName] = useState("");
  const [appMiddleInitial, setAppMiddleInitial] = useState("");
  const [appLastName, setAppLastName] = useState("");
  const [appPhone, setAppPhone] = useState("");
  const [appAge, setAppAge] = useState("");
  const [appSex, setAppSex] = useState("");
  const [appBirthdate, setAppBirthdate] = useState(new Date());
  const [appShowSexDropdown, setAppShowSexDropdown] = useState(false);
  const [appShowDatePicker, setAppShowDatePicker] = useState(false);
  const [appAddress, setAppAddress] = useState("");
  const [appValidIdImage, setAppValidIdImage] = useState(null); // { uri }
  const [appSelfieImage, setAppSelfieImage] = useState(null);   // { uri }
  const [appSubmitting, setAppSubmitting] = useState(false);
  const [hasPendingRequest, setHasPendingRequest] = useState(false);


  // Function to upload artwork image to the backend and refresh gallery
  const uploadArtwork = async (imageUri, meta = {}) => {
    try {
      // Ensure we have tokens; if not, try to fetch current session
      let at = accessToken;
      let rt = refreshToken;
      if (!at || !rt) {
        const { data } = await supabase.auth.getSession();
        at = data?.session?.access_token || at;
        rt = data?.session?.refresh_token || rt;
        if (at) setAccessToken(at);
        if (rt) setRefreshToken(rt);
      }
      const fd = new FormData();
      // Backend expects file under field name 'images'
      fd.append("images", {
        uri: imageUri,
        name: "artwork.jpg",
        type: "image/jpeg",
      });
      // Optional metadata supported by backend: title, description, medium
      if (meta.title != null) fd.append("title", String(meta.title));
      if (meta.description != null) fd.append("description", String(meta.description));
      if (meta.medium != null) fd.append("medium", String(meta.medium));
      
      // Watermark settings
      if (meta.applyWatermark != null) fd.append("applyWatermark", String(meta.applyWatermark));
      if (meta.watermarkText != null && meta.watermarkText.trim()) fd.append("watermarkText", String(meta.watermarkText.trim()));


      const res = await fetch(${API_BASE}/profile/uploadArt, {
        method: "POST",
        headers: {
          // Include auth cookies so backend can read req.user
          Cookie: access_token=${at}; refresh_token=${rt},
        },
        body: fd,
      });


      if (!res.ok) {
        let msg = res.statusText;
        try {
          const bodyText = await res.text();
          try {
            const bodyJson = bodyText ? JSON.parse(bodyText) : null;
            msg = bodyJson?.error || bodyJson?.message || bodyText || msg;
          } catch (_) {
            msg = bodyText || msg;
          }
        } catch (_) {}
        console.log("[uploadArtwork] failed:", res.status, msg);
        throw new Error(Upload failed (${res.status}): ${msg});
      }


      const data = await res.json();
      console.log("Upload response:", data);
      // Refresh gallery after successful upload
      await fetchGallery(at, rt);
    } catch (err) {
      console.error("Error uploading artwork:", err);
      alert("Failed to upload artwork");
    }
  };


  // Load reactions and comments when an artwork is opened
  useEffect(() => {
    const load = async () => {
      if (!selectedArt?.id) return;
      setDescriptionExpanded(false); // Reset description state
      await Promise.all([
        fetchArtReacts(selectedArt.id),
        fetchArtComments(selectedArt.id),
      ]);
    };
    load();
  }, [selectedArt]);


  const fetchArtReacts = async (artId) => {
    try {
      let at = accessToken, rt = refreshToken;
      if (!at || !rt) {
        const { data } = await supabase.auth.getSession();
        at = data?.session?.access_token || at;
        rt = data?.session?.refresh_token || rt;
      }
      const res = await fetch(${API_BASE}/profile/getReact?artId=${artId}, {
        method: "GET",
        headers: { Cookie: access_token=${at}; refresh_token=${rt} },
      });
      if (!res.ok) return;
      const bodyText = await res.text();
      let data = null; try { data = bodyText ? JSON.parse(bodyText) : null; } catch { data = null; }
      const reactions = data?.reactions || [];
      setArtLikesCount(reactions.length || 0);
      // Determine if current user liked
      const session = await supabase.auth.getSession();
      const uid = session?.data?.session?.user?.id;
      setArtUserLiked(!!reactions.find(r => r.userId === uid));
    } catch {}
  };


  const fetchArtComments = async (artId, page = 1, append = false) => {
    try {
      let at = accessToken, rt = refreshToken;
      if (!at || !rt) {
        const { data } = await supabase.auth.getSession();
        at = data?.session?.access_token || at;
        rt = data?.session?.refresh_token || rt;
      }
      const res = await fetch(${API_BASE}/profile/getComments?artId=${artId}&page=${page}&limit=10, {
        method: "GET",
        headers: { Cookie: access_token=${at}; refresh_token=${rt} },
      });
      if (!res.ok) return;
      const json = await res.json();
      const newComments = json?.comments || [];
      const total = json?.totalCount || json?.total || json?.count;
      
      if (append) {
        setArtComments(prev => [...prev, ...newComments]);
      } else {
        setArtComments(newComments);
        // Set total count only on first load
        if (total !== undefined) {
          setTotalCommentCount(total);
        } else {
          setTotalCommentCount(newComments.length);
        }
      }
      
      setCommentPage(page);
      setHasMoreComments(newComments.length >= 10);
    } catch {}
    finally {
      setLoadingMoreComments(false);
    }
  };


  const loadMoreArtComments = () => {
    const artwork = commentingArt || selectedArt;
    if (!loadingMoreComments && hasMoreComments && artwork?.id) {
      fetchArtComments(artwork.id, commentPage + 1, true);
    }
  };
  
  const showLessArtComments = () => {
    const artwork = commentingArt || selectedArt;
    if (artwork?.id) {
      fetchArtComments(artwork.id, 1, false);
    }
  };

  const handleToggleArtLike = async () => {
    if (!selectedArt?.id) return;
    const prevLiked = artUserLiked;
    const prevCount = artLikesCount;
    setArtUserLiked(!prevLiked);
    setArtLikesCount(prevLiked ? Math.max(0, prevCount - 1) : prevCount + 1);
    try {
      let at = accessToken, rt = refreshToken;
      if (!at || !rt) {
        const { data } = await supabase.auth.getSession();
        at = data?.session?.access_token || at;
        rt = data?.session?.refresh_token || rt;
      }
      const res = await fetch(${API_BASE}/profile/createReact, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Cookie: access_token=${at}; refresh_token=${rt},
        },
        body: JSON.stringify({ artId: selectedArt.id }),
      });
      if (!res.ok) throw new Error('react failed');
      await fetchArtReacts(selectedArt.id);
    } catch {
      // revert on failure
      setArtUserLiked(prevLiked);
      setArtLikesCount(prevCount);
    }
  };


  // Render function for comment items
  const renderArtComment = useCallback(({ item }) => (
    <View style={{ flexDirection: 'row', marginBottom: 16, paddingHorizontal: 16 }}>
      {item.user?.avatar ? (
        <Image 
          source={{ uri: item.user?.avatar }} 
          style={{ width: 40, height: 40, borderRadius: 20, marginRight: 12 }} 
        />
      ) : (
        <View style={{ width: 40, height: 40, borderRadius: 20, marginRight: 12, backgroundColor: '#ddd', justifyContent: 'center', alignItems: 'center' }}>
          <Ionicons name="person" size={24} color="#999" />
        </View>
      )}
      <View style={{ flex: 1, position: 'relative' }}>
        <View style={{ backgroundColor: '#fff', padding: 12, borderRadius: 12, shadowColor: '#000', shadowOffset: { width: 0, height: 1 }, shadowOpacity: 0.05, shadowRadius: 2, elevation: 1 }}>
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <Text style={{ flex: 1, fontWeight: 'bold', fontSize: 14, marginRight: 8 }} numberOfLines={1}>{item.user?.name}</Text>
            <TouchableOpacity onPress={() => onOpenCommentMenu(item)} hitSlop={{ top: 8, bottom: 8, left: 8, right: 8 }}>
              <Ionicons name="ellipsis-horizontal" size={18} color="#777" />
            </TouchableOpacity>
          </View>

          {editingCommentId === item.id ? (
            <View>
              <TextInput
                style={{ marginTop: 6, fontSize: 14, color: '#333', backgroundColor: '#f5f5f5', borderRadius: 8, paddingHorizontal: 10, paddingVertical: 8 }}
                value={editCommentText}
                onChangeText={setEditCommentText}
                multiline
              />
              <View style={{ flexDirection: 'row', justifyContent: 'flex-end', marginTop: 8 }}>
                <TouchableOpacity onPress={cancelEditComment} style={{ paddingVertical: 6, paddingHorizontal: 10, marginRight: 8 }}>
                  <Text style={{ color: '#777' }}>Cancel</Text>
                </TouchableOpacity>
                <TouchableOpacity onPress={() => saveEditComment(item)} style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#A68C7B', borderRadius: 6 }}>
                  <Text style={{ color: '#fff', fontWeight: '600' }}>Save</Text>
                </TouchableOpacity>
              </View>
            </View>
          ) : (
            <>
              <Text style={{ fontSize: 14, color: '#333', marginTop: 6 }}>{item.text}</Text>
              {!!item.timestamp && (
                <Text style={{ fontSize: 12, color: '#888', marginTop: 6 }}>{item.timestamp}</Text>
              )}
            </>
          )}
        </View>

        {commentMenuForId === item.id && (
          <View style={{ position: 'absolute', top: 30, right: 6, backgroundColor: '#fff', borderRadius: 8, shadowColor: '#000', shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.15, shadowRadius: 4, elevation: 5, overflow: 'hidden', width: 160, zIndex: 10 }}>
            {item.user?.id === currentUserId ? (
              <View>
                <TouchableOpacity onPress={() => startEditComment(item)} style={{ paddingVertical: 10, paddingHorizontal: 14, flexDirection: 'row', alignItems: 'center' }}>
                  <Ionicons name="create-outline" size={18} color="#555" style={{ marginRight: 10 }} />
                  <Text style={{ color: '#333' }}>Edit</Text>
                </TouchableOpacity>
                <View style={{ height: 1, backgroundColor: '#eee' }} />
                <TouchableOpacity onPress={() => deleteArtComment(item)} style={{ paddingVertical: 10, paddingHorizontal: 14, flexDirection: 'row', alignItems: 'center' }}>
                  <Ionicons name="trash-outline" size={18} color="#d9534f" style={{ marginRight: 10 }} />
                  <Text style={{ color: '#d9534f' }}>Delete</Text>
                </TouchableOpacity>
              </View>
            ) : (
              <TouchableOpacity onPress={() => reportArtComment(item)} style={{ paddingVertical: 10, paddingHorizontal: 14, flexDirection: 'row', alignItems: 'center' }}>
                <Ionicons name="flag-outline" size={18} color="#555" style={{ marginRight: 10 }} />
                <Text style={{ color: '#333' }}>Report</Text>
              </TouchableOpacity>
            )}
          </View>
        )}
      </View>
    </View>
  ), [commentMenuForId, editingCommentId, editCommentText, currentUserId]);

  // Comment menu handlers
  const onOpenCommentMenu = (comment) => {
    setCommentMenuForId(prev => (prev === comment.id ? null : comment.id));
    if (editingCommentId && editingCommentId !== comment.id) {
      setEditingCommentId(null);
      setEditCommentText('');
    }
  };

  const startEditComment = (comment) => {
    setEditingCommentId(comment.id);
    setEditCommentText(comment.text || '');
    setCommentMenuForId(null);
  };

  const cancelEditComment = () => {
    setEditingCommentId(null);
    setEditCommentText('');
    setCommentMenuForId(null);
  };

  const saveEditComment = async (comment) => {
    const newText = (editCommentText || '').trim();
    if (!newText) {
      Alert.alert('Edit Comment', 'Comment cannot be empty.');
      return;
    }
    try {
      let at = accessToken, rt = refreshToken;
      if (!at || !rt) {
        const { data } = await supabase.auth.getSession();
        at = data?.session?.access_token || at;
        rt = data?.session?.refresh_token || rt;
      }
      const res = await fetch(${API_BASE}/profile/updateComment/${comment.id}, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Cookie: access_token=${at}; refresh_token=${rt},
        },
        body: JSON.stringify({ text: newText }),
      });
      if (!res.ok) throw new Error('Failed to update comment');
      setArtComments(prev => prev.map(c => (
        c.id === comment.id ? { ...c, text: newText, updatedAt: new Date().toISOString() } : c
      )));
    } catch (err) {
      console.error(err);
      Alert.alert('Edit Comment', 'Unable to update comment.');
    } finally {
      setEditingCommentId(null);
      setEditCommentText('');
      setCommentMenuForId(null);
    }
  };

  const deleteArtComment = async (comment) => {
    Alert.alert('Delete Comment', 'Are you sure you want to delete this comment?', [
      { text: 'Cancel', style: 'cancel' },
      {
        text: 'Delete', style: 'destructive', onPress: async () => {
          try {
            let at = accessToken, rt = refreshToken;
            if (!at || !rt) {
              const { data } = await supabase.auth.getSession();
              at = data?.session?.access_token || at;
              rt = data?.session?.refresh_token || rt;
            }
            const res = await fetch(${API_BASE}/profile/deleteComment/${comment.id}, {
              method: 'DELETE',
              headers: {
                Cookie: access_token=${at}; refresh_token=${rt},
              },
            });
            if (!res.ok) throw new Error('Failed to delete');
            setArtComments(prev => prev.filter(c => c.id !== comment.id));
            setTotalCommentCount(prev => Math.max(0, prev - 1));
          } catch (e) {
            console.error(e);
            Alert.alert('Delete Comment', 'Unable to delete comment.');
          } finally {
            setCommentMenuForId(null);
          }
        }
      }
    ]);
  };

  const reportArtComment = async (comment) => {
    try {
      let at = accessToken, rt = refreshToken;
      if (!at || !rt) {
        const { data } = await supabase.auth.getSession();
        at = data?.session?.access_token || at;
        rt = data?.session?.refresh_token || rt;
      }
      const res = await fetch(${API_BASE}/profile/reportComment, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Cookie: access_token=${at}; refresh_token=${rt},
        },
        body: JSON.stringify({ commentId: comment.id, reason: 'Inappropriate' }),
      });
      if (!res.ok) throw new Error('Failed to report');
      Alert.alert('Report', 'Thanks for your report. Our team will review it.');
    } catch (e) {
      console.error(e);
      Alert.alert('Report', 'Unable to send report right now.');
    } finally {
      setCommentMenuForId(null);
    }
  };

  const postArtComment = async () => {
    // Use commentingArt if in comments modal, otherwise use selectedArt
    const artwork = commentingArt || selectedArt;
    if (!artwork?.id || !artNewComment.trim()) return;
    const text = artNewComment.trim();
    setArtNewComment("");
    try {
      let at = accessToken, rt = refreshToken;
      if (!at || !rt) {
        const { data } = await supabase.auth.getSession();
        at = data?.session?.access_token || at;
        rt = data?.session?.refresh_token || rt;
      }
      const res = await fetch(${API_BASE}/profile/createComment, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Cookie: access_token=${at}; refresh_token=${rt},
        },
        body: JSON.stringify({ artId: artwork.id, text }),
      });
      if (!res.ok) throw new Error('comment failed');
      await fetchArtComments(artwork.id);
    } catch {}
  };

  // Open edit modal with artwork data
  const handleEditArtwork = (art) => {
    setEditingArt(art);
    setEditArtTitle(art.title || '');
    setEditArtDescription(art.description || '');
    setEditArtMedium(art.medium || '');
    setEditArtImage(null); // Don't pre-populate, let user choose new image
    setSelectedArt(null); // Close detail modal
    setEditModalVisible(true);
  };

  // Pick new image for edit
  const pickEditArtworkImage = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [1, 1],
      quality: 1,
    });
    if (!result.canceled) {
      setEditArtImage({ uri: result.assets[0].uri });
    }
  };

  // Submit edited artwork
  const submitEditArtwork = async () => {
    try {
      if (!editArtTitle.trim()) {
        Alert.alert('Error', 'Please enter a title');
        return;
      }
      if (!editingArt?.id) {
        Alert.alert('Error', 'Invalid artwork');
        return;
      }

      setEditArtUploading(true);

      let at = accessToken;
      let rt = refreshToken;
      if (!at || !rt) {
        const { data } = await supabase.auth.getSession();
        at = data?.session?.access_token || at;
        rt = data?.session?.refresh_token || rt;
      }

      const formData = new FormData();
      
      // Add text fields
      formData.append('title', editArtTitle);
      formData.append('description', editArtDescription);
      formData.append('medium', editArtMedium);

      // Handle images based on whether user selected a new one
      if (editArtImage?.uri) {
        // New image selected - upload it
        formData.append('images', {
          uri: editArtImage.uri,
          name: 'artwork.jpg',
          type: 'image/jpeg',
        });
        // Mark old image for removal (append individually, not as JSON string)
        if (editingArt.image) {
          formData.append('imagesToRemove', editingArt.image);
        }
      } else {
        // No new image selected - keep existing image (append individually)
        if (editingArt.image) {
          formData.append('existingImages', editingArt.image);
        }
      }

      const res = await fetch(${API_BASE}/profile/art/${editingArt.id}, {
        method: 'PUT',
        headers: {
          Cookie: access_token=${at}; refresh_token=${rt},
        },
        body: formData,
      });

      if (!res.ok) {
        const errText = await res.text();
        throw new Error(errText || 'Update failed');
      }

      Alert.alert('Success', 'Artwork updated successfully!');
      setEditModalVisible(false);
      setEditingArt(null);
      await fetchGallery(at, rt);
    } catch (err) {
      console.error('Edit artwork error:', err);
      Alert.alert('Error', err.message || 'Failed to update artwork');
    } finally {
      setEditArtUploading(false);
    }
  };

  // Delete artwork
  const handleDeleteArtwork = (art) => {
    Alert.alert(
      'Delete Artwork',
      'Are you sure you want to delete this artwork? This action cannot be undone.',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            try {
              let at = accessToken;
              let rt = refreshToken;
              if (!at || !rt) {
                const { data } = await supabase.auth.getSession();
                at = data?.session?.access_token || at;
                rt = data?.session?.refresh_token || rt;
              }

              const res = await fetch(${API_BASE}/profile/art/${art.id}, {
                method: 'DELETE',
                headers: {
                  Cookie: access_token=${at}; refresh_token=${rt},
                },
              });

              if (!res.ok) {
                const errText = await res.text();
                throw new Error(errText || 'Delete failed');
              }

              Alert.alert('Success', 'Artwork deleted successfully!');
              setSelectedArt(null); // Close modal
              await fetchGallery(at, rt);
            } catch (err) {
              console.error('Delete artwork error:', err);
              Alert.alert('Error', err.message || 'Failed to delete artwork');
            }
          },
        },
      ]
    );
  };
  

  const formattedDate = birthday
    ? birthday.toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" })
    : "";
  const formattedTempDate = tempBirthday
    ? tempBirthday.toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" })
    : "";


  const handleAddImage = async () => {
    // Only artists/admin can upload
    const r = String(role || '').toLowerCase();
    if (!(r === 'artist' || r === 'admin')) {
      console.log('[profile.js] Upload blocked due to role:', role);
      Alert.alert('Not allowed', 'Only artists can upload artworks.');
      return;
    }
    // Open modal to collect artwork metadata and image
    setArtImage(null);
    setArtTitle("");
    setArtDescription("");
    setArtMedium("");
    setArtModalVisible(true);
  };


  const pickArtworkImage = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [1, 1],
      quality: 1,
    });
    if (!result.canceled) {
      setArtImage({ uri: result.assets[0].uri });
    }
  };


  const submitArtwork = async () => {
    try {
      if (!artTitle.trim()) {
        Alert.alert('Error', 'Please enter a title');
        return;
      }
      if (!artImage?.uri) {
        Alert.alert('Error', 'Please select an artwork image');
        return;
      }
      setArtUploading(true);
      await uploadArtwork(artImage.uri, {
        title: artTitle,
        description: artDescription,
        medium: artMedium,
        applyWatermark: artApplyWatermark,
        watermarkText: artWatermarkText,
      });
      Alert.alert('Success', 'Artwork uploaded successfully!');
      setArtModalVisible(false);
      setArtImage(null);
      setArtTitle('');
      setArtDescription('');
      setArtMedium('');
    } catch (e) {
      // uploadArtwork already alerts on failure
    } finally {
      setArtUploading(false);
    }
  };


  const handleApplyAsArtist = () => {
    console.log('[profile.js] Apply as Artist clicked. Current role =', role);
    // Prefill from existing profile data if available
    setAppFirstName(firstName || "");
    setAppMiddleInitial((middleName || "").slice(0,1).toUpperCase());
    setAppLastName(lastName || "");
    setAppSex(sex || "");
    setAppBirthdate(birthday || new Date());
    setAppAddress(address || "");
    setAppPhone("");
    setAppAge("");
    setAppValidIdImage(null);
    setAppSelfieImage(null);
    setApplyModalVisible(true);
  };

  const pickValidIdImage = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [4, 3],
      quality: 1,
    });
    if (!result.canceled) {
      setAppValidIdImage({ uri: result.assets[0].uri });
    }
  };

  const pickSelfieImage = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [1, 1],
      quality: 1,
    });
    if (!result.canceled) {
      setAppSelfieImage({ uri: result.assets[0].uri });
    }
  };

  const onChangeAppDate = (event, selectedDate) => {
    if (selectedDate) setAppBirthdate(selectedDate);
    if (Platform.OS === 'android') setAppShowDatePicker(false);
  };

  const submitArtistApplication = async () => {
    try {
      if (!appFirstName || !appLastName || !appPhone || !appAge || !appSex || !appBirthdate || !appAddress || !appValidIdImage || !appSelfieImage) {
        Alert.alert('Incomplete', 'Please fill in all fields and attach both images.');
        return;
      }
      setAppSubmitting(true);

      // Ensure tokens
      let at = accessToken, rt = refreshToken;
      if (!at || !rt) {
        const { data } = await supabase.auth.getSession();
        at = data?.session?.access_token || at;
        rt = data?.session?.refresh_token || rt;
      }

      // Build multipart form data to mirror the web submission to admin
      const fd = new FormData();
      fd.append('requestType', 'artist_verification');
      fd.append('firstName', String(appFirstName));
      fd.append('midInit', String(appMiddleInitial || ''));
      fd.append('lastName', String(appLastName));
      fd.append('phone', String(appPhone));
      fd.append('age', String(appAge));
      fd.append('sex', String(appSex));
      fd.append('birthdate', new Date(appBirthdate).toISOString());
      fd.append('address', String(appAddress));
      fd.append('portfolio', '');
      fd.append('bio', '');
      // Consent required by web flow; RN UI has no toggle, so set true to match web behavior
      fd.append('consent', 'true');
      // Files must be under field names 'file' and 'file2' as in the web app
      fd.append('file', { uri: appValidIdImage.uri, name: 'valid_id.jpg', type: 'image/jpeg' });
      fd.append('file2', { uri: appSelfieImage.uri, name: 'selfie.jpg', type: 'image/jpeg' });

      const endpoint = ${API_BASE}/request/registerAsArtist;
      console.log('[profile.js] Submitting artist application to (admin/web route):', endpoint);
      const res = await fetch(endpoint, {
        method: 'POST',
        headers: { Cookie: access_token=${at}; refresh_token=${rt} },
        body: fd,
      });
      const bodyText = await res.text();
      console.log('[profile.js] Application response:', res.status, bodyText);
      if (!res.ok) throw new Error(bodyText || 'Application failed');

      // Trigger existing refresh logic to update profile/gallery state
      try { await onRefresh(); } catch (_) {}
      Alert.alert('Submitted', 'Your application has been submitted.');
      setApplyModalVisible(false);
    } catch (e) {
      console.error('[profile.js] submitArtistApplication error:', e?.message || e);
      Alert.alert('Failed', e?.message || 'Could not submit application');
    } finally {
      setAppSubmitting(false);
    }
  };

  // Role now comes from UserContext - no need to fetch separately

  // Check if user has a pending artist verification request
  const checkPendingRequest = async (at, rt) => {
    try {
      const res = await fetch(${API_BASE}/request/getRequest, {
        method: "GET",
        credentials: "include",
        headers: {
          Cookie: access_token=${at}; refresh_token=${rt},
        },
      });
      if (!res.ok) {
        setHasPendingRequest(false);
        return false;
      }
      const data = await res.json();
      
      // Check if there's a pending artist_verification request
      if (data?.requests && Array.isArray(data.requests)) {
        const pendingArtistRequest = data.requests.find(
          req => req.requestType === 'artist_verification' && req.status === 'pending'
        );
        const hasPending = !!pendingArtistRequest;
        setHasPendingRequest(hasPending);
        console.log("[profile.js] Pending artist request:", hasPending);
        return hasPending;
      }
      setHasPendingRequest(false);
      return false;
    } catch (error) {
      console.error("[profile.js] Error checking pending request:", error?.message || error);
      setHasPendingRequest(false);
      return false;
    }
  };


  useEffect(() => {
    const init = async () => {
      try {
        const { data } = await supabase.auth.getSession();
        const at = data?.session?.access_token || null;
        const rt = data?.session?.refresh_token || null;
        setAccessToken(at);
        setRefreshToken(rt);

        if (at && rt) {
          // Refresh user data from UserContext to get latest role
          await refreshUserData();
          await fetchProfile(at, rt);
          await checkPendingRequest(at, rt);
          // Use role from UserContext
          const userRole = userData?.role || role;
          if (String(userRole || '').toLowerCase() === 'artist' || String(userRole || '').toLowerCase() === 'admin') {
            await fetchGallery(at, rt);
          } else {
            console.log('[profile.js] Role not permitted to view gallery. Skipping fetchGallery. role =', userRole);
            setGalleryImages([]);
          }
        } else {
          await fetchSupabaseProfile();
        }
      } catch (e) {
        console.warn("Init session failed:", e?.message || e);
      }
    };
    init();
  }, []);

  // Debug: log role changes to verify UI conditions
  useEffect(() => {
    console.log('[profile.js] role state now:', role);
  }, [role]);

  
  const fetchSupabaseProfile = async () => {
    try {
      // Note: This app uses backend API for profile data, not Supabase tables
      // Supabase is only used for authentication
      // If we reach here, it means no session exists - profile data will load after login
      console.log('[profile.js] No active session - profile will load after authentication');
    } catch (err) {
      console.warn("Profile initialization warning:", err.message);
    }
  };


  const getInitials = () => {
    const parts = [firstName, middleName, lastName].filter(Boolean);
    let base = parts.join(" ");
    if (!base && username) base = username;
    if (!base) return "";
    const tokens = base.trim().split(/\s+/);
    return tokens
      .slice(0, 2)
      .map((t) => t[0]?.toUpperCase())
      .join("");
  };


  const fetchProfile = async (at = accessToken, rt = refreshToken) => {
    try {
      const res = await fetch(${API_BASE}/profile/getProfile, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Cookie: access_token=${at}; refresh_token=${rt},
        },
      });
      if (!res.ok) throw new Error(Failed to fetch profile (${res.status}));


      const data = await res.json();
      const p = data?.profile ?? data;


      setFirstName(p.firstName || "");
      setMiddleName(p.middleName || "");
      setLastName(p.lastName || "");
      setUserNameField(p.username || "");
      setUsername(p.username || "");
      setSex(p.sex || "");
      setAddress(p.address || "");
      setBio(p.bio || "");
      setAbout(p.about || "");


      const fetchedBday = p.birthday || p.birthdate;
      if (fetchedBday) {
        const parsedDate = new Date(fetchedBday);
        setBirthday(parsedDate);
        await AsyncStorage.setItem("userBirthday", parsedDate.toISOString());
      }


      const resolveUrl = (u) => {
        if (!u) return null;
        return u.startsWith("http") ? u : ${API_ORIGIN}${u};
      };
      const avatarUrl = resolveUrl(p.profilePicture);
      const coverUrl = resolveUrl(p.coverPicture);
      setImage(avatarUrl ? { uri: avatarUrl } : null);
      setBackgroundImage(coverUrl ? { uri: coverUrl } : null);
    } catch (err) {
      console.warn("Profile fetch failed:", err.message);
      await fetchSupabaseProfile();
    }
  };


  // Fetch user's artworks and populate galleryImages
  const fetchGallery = async (at = accessToken, rt = refreshToken) => {
    try {
      const res = await fetch(${API_BASE}/profile/getArts, {
        method: "GET",
        headers: {
          Cookie: access_token=${at}; refresh_token=${rt},
        },
      });
      if (!res.ok) throw new Error(Failed to fetch gallery (${res.status}));
      const data = await res.json();
      const list = Array.isArray(data) ? data : (data?.arts || data || []);
      const items = list.map((a) => {
        console.log('[profile.js] Raw artwork data:', JSON.stringify(a));
        
        // Image is stored as JSONB array, extract first URL
        let imageUrl = null;
        if (Array.isArray(a?.image) && a.image.length > 0) {
          imageUrl = a.image[0];
          console.log('[profile.js] Initial imageUrl from array:', imageUrl);
          
          // Handle double-encoded JSON strings (e.g., "[\"url\"]" instead of "url")
          if (typeof imageUrl === 'string' && imageUrl.startsWith('[')) {
            console.log('[profile.js] Detected double-encoded JSON, attempting to parse...');
            try {
              const parsed = JSON.parse(imageUrl);
              console.log('[profile.js] Parsed result:', parsed);
              if (Array.isArray(parsed) && parsed.length > 0) {
                imageUrl = parsed[0];
                console.log('[profile.js] Extracted URL from parsed array:', imageUrl);
              }
            } catch (e) {
              console.error('[profile.js] Failed to parse double-encoded image:', imageUrl, e);
            }
          }
        } else if (typeof a?.image === 'string') {
          imageUrl = a.image;
          console.log('[profile.js] imageUrl from string:', imageUrl);
        }
        
        // Make URL absolute if needed and validate
        let abs = null;
        if (imageUrl) {
          // Remove any extra quotes or whitespace
          imageUrl = String(imageUrl).trim().replace(/^"+|"+$/g, '');
          console.log('[profile.js] Cleaned imageUrl:', imageUrl);
          
          if (imageUrl.startsWith("http")) {
            abs = imageUrl;
          } else if (imageUrl.startsWith("/")) {
            abs = ${API_ORIGIN}${imageUrl};
          } else {
            abs = ${API_ORIGIN}/${imageUrl};
          }
          
          // Add cache busting parameter to force reload of watermarked images
          if (abs) {
            const separator = abs.includes('?') ? '&' : '?';
            abs = ${abs}${separator}_=${Date.now()};
          }
        }
        
        console.log('[profile.js] Final processed URL:', abs);
        console.log('[profile.js] =============================');
        
        return {
          id: a?.artId || a?.id || null,
          image: abs,
          title: a?.title || null,
          description: a?.description || null,
          medium: a?.medium || null,
          timestamp: a?.timestamp || a?.datePosted || null,
        };
      }).filter(x => {
        const hasImage = !!x.image;
        if (!hasImage) {
          console.log('[profile.js] Filtered out item with no image:', x.title);
        }
        return hasImage;
      });
      setGalleryImages(items);
    } catch (e) {
      console.warn("Gallery fetch failed:", e?.message || e);
    }
  };


  useFocusEffect(
    useCallback(() => {
      const init = async () => {
        const { data } = await supabase.auth.getSession();
        const uid = data?.session?.user?.id;
        if (uid) setCurrentUserId(uid);
      };
      init();
      fetchProfile();
      const r = String(role || '').toLowerCase();
      if (accessToken && refreshToken && (r === 'artist' || r === 'admin')) {
        fetchGallery(accessToken, refreshToken);
      } else if (accessToken && refreshToken) {
        console.log('[profile.js] Focus effect: role not permitted to view gallery. role =', role);
        setGalleryImages([]);
      }
    }, [role, accessToken, refreshToken])
  );

  // Pull to refresh handler
  const onRefresh = async () => {
    setRefreshing(true);
    try {
      // Role now comes from UserContext automatically
      const r = String(role || '').toLowerCase();
      
      if (r === 'artist' || r === 'admin') {
        await Promise.all([
          fetchProfile(accessToken, refreshToken),
          fetchGallery(accessToken, refreshToken),
          checkPendingRequest(accessToken, refreshToken)
        ]);
      } else {
        await Promise.all([
          fetchProfile(accessToken, refreshToken),
          checkPendingRequest(accessToken, refreshToken)
        ]);
      }
    } catch (err) {
      console.error('Refresh error:', err);
    } finally {
      setRefreshing(false);
    }
  };


  const pickImage = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [1, 1],
      quality: 1,
    });
    if (!result.canceled) {
      const uri = result.assets[0].uri;
      const imgObj = { uri };
      setTempImage(imgObj);
      setImage(imgObj);
    }
  };


  const pickBackgroundImage = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [16, 9],
      quality: 1,
    });
    if (!result.canceled) {
      const uri = result.assets[0].uri;
      const bgObj = { uri };
      setTempBackgroundImage(bgObj);
      setBackgroundImage(bgObj);
    }
  };


  const handleSave = async () => {
    try {
      const formData = new FormData();
      if (tempImage) {
        const filename = tempImage.uri.split("/").pop();
        const match = /\.(\w+)$/.exec(filename);
        const type = match ? image/${match[1]} : "image";
        formData.append("avatar", { uri: tempImage.uri, name: filename, type });
      }
      if (tempBackgroundImage) {
        const filename = tempBackgroundImage.uri.split("/").pop();
        const match = /\.(\w+)$/.exec(filename);
        const type = match ? image/${match[1]} : "image";
        formData.append("cover", { uri: tempBackgroundImage.uri, name: filename, type });
      }


      formData.append("firstName", String(tempFirstName ?? ""));
      formData.append("middleName", String(tempMiddleName ?? ""));
      formData.append("lastName", String(tempLastName ?? ""));
      formData.append("username", String(tempUserNameField || username || ""));
      formData.append("sex", String(tempSex ?? ""));
      const birthdayISO = tempBirthday ? new Date(tempBirthday).toISOString() : "";
      formData.append("birthday", birthdayISO);
      formData.append("birthdate", birthdayISO);
      formData.append("address", String(tempAddress ?? ""));
      formData.append("bio", String(tempBio ?? ""));
      formData.append("about", String(tempAbout ?? ""));


      if (tempBirthday) {
        await AsyncStorage.setItem("userBirthday", new Date(tempBirthday).toISOString());
      }


      const res = await fetch(${API_BASE}/profile/updateProfile, {
        method: "POST",
        headers: {
          Cookie: access_token=${accessToken}; refresh_token=${refreshToken},
        },
        body: formData,
      });


      if (!res.ok) {
        let errorMsg = "Failed to update profile";
        try {
          const errorData = await res.json();
          errorMsg = errorData?.message || errorData?.error || errorMsg;
        } catch {}
        throw new Error(errorMsg);
      }


      setModalVisible(false);
      setTempImage(null);
      setTempBackgroundImage(null);
      await fetchProfile();


      Alert.alert("Success", "Profile updated successfully!");
    } catch (err) {
      console.error("Profile update error:", err);
      Alert.alert("Update Failed", err?.message || "Failed to save profile information");
    }
  };


  const onChangeTempDate = (event, selectedDate) => {
    if (selectedDate) setTempBirthday(selectedDate);
    if (Platform.OS === "android") setShowDatePicker(false);
  };


  return (
    <SafeAreaView style={styles.container}>
      <Header title="Profile" showSearch={false} />
      <ScrollView 
        style={styles.scrollContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={['#000']} // Android
            tintColor="#000" // iOS
          />
        }
      >


      {/* Profile Section */}
      <View style={styles.profileSection}>
        {backgroundImage ? (
          <Image source={backgroundImage} style={styles.backgroundImage} />
        ) : (
          <Image source={require("../../assets/pic1.jpg")} style={styles.backgroundImage} />
        )}


      {/* Apply as Artist Modal */}
      <Modal
        visible={applyModalVisible}
        animationType="slide"
        transparent
        onRequestClose={() => setApplyModalVisible(false)}
      >
        <KeyboardAvoidingView 
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <View style={styles.uploadModalOverlay}>
            <View style={styles.uploadModalContent}>
              <View style={styles.uploadModalHeader}>
                <Text style={styles.uploadModalTitle}>Apply as Artist</Text>
                <TouchableOpacity onPress={() => setApplyModalVisible(false)}>
                  <Ionicons name="close" size={24} color="#333" />
                </TouchableOpacity>
              </View>

              <ScrollView style={styles.uploadModalBody} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">

                <Text style={styles.uploadInputLabel}>First Name *</Text>
                <TextInput style={styles.uploadInput} placeholder="First Name" value={appFirstName} onChangeText={setAppFirstName} />
                
                <Text style={styles.uploadInputLabel}>Middle Initial</Text>
                <TextInput style={styles.uploadInput} placeholder="Middle Initial" value={appMiddleInitial} onChangeText={setAppMiddleInitial} maxLength={1} />
                
                <Text style={styles.uploadInputLabel}>Last Name *</Text>
                <TextInput style={styles.uploadInput} placeholder="Last Name" value={appLastName} onChangeText={setAppLastName} />
                
                <Text style={styles.uploadInputLabel}>Phone Number *</Text>
                <TextInput style={styles.uploadInput} placeholder="Phone Number" keyboardType="phone-pad" value={appPhone} onChangeText={setAppPhone} />
                
                <Text style={styles.uploadInputLabel}>Age *</Text>
                <TextInput style={styles.uploadInput} placeholder="Age" keyboardType="numeric" value={appAge} onChangeText={setAppAge} />

                <Text style={styles.uploadInputLabel}>Sex *</Text>
                <TouchableOpacity style={styles.uploadInput} onPress={() => setAppShowSexDropdown(!appShowSexDropdown)}>
                  <Text style={{ color: appSex ? '#000' : '#999' }}>{appSex || 'Select Sex'}</Text>
                  <Ionicons name={appShowSexDropdown ? 'chevron-up' : 'chevron-down'} size={20} color="#555" style={{ position: 'absolute', right: 12, top: 12 }} />
                </TouchableOpacity>
                {appShowSexDropdown && (
                  <View style={styles.categoryDropdown}>
                    {['Male', 'Female', 'PreferNotToSay'].map(item => (
                      <TouchableOpacity key={item} style={styles.categoryItem} onPress={() => { setAppSex(item); setAppShowSexDropdown(false); }}>
                        <Text style={styles.categoryItemText}>{item}</Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}

                <Text style={styles.uploadInputLabel}>Birthdate *</Text>
                <TouchableOpacity style={styles.uploadInput} onPress={() => setAppShowDatePicker(true)}>
                  <Text style={{ color: appBirthdate ? '#000' : '#999' }}>
                    {appBirthdate ? appBirthdate.toLocaleDateString('en-US') : 'Select your birthdate'}
                  </Text>
                </TouchableOpacity>
                {appShowDatePicker && (
                  <DateTimePicker value={appBirthdate} mode="date" display="default" onChange={onChangeAppDate} />
                )}

                <Text style={styles.uploadInputLabel}>Address *</Text>
                <TextInput style={styles.uploadInput} placeholder="Address" value={appAddress} onChangeText={setAppAddress} />

                <Text style={styles.uploadInputLabel}>Valid ID *</Text>
                <TouchableOpacity onPress={pickValidIdImage} style={styles.uploadImagePicker}>
                  {appValidIdImage ? (
                    <Image source={appValidIdImage} style={styles.uploadPickedImage} />
                  ) : (
                    <View style={styles.uploadImagePlaceholder}>
                      <Ionicons name="card-outline" size={48} color="#A68C7B" />
                      <Text style={styles.uploadImageText}>Tap to upload Valid ID</Text>
                    </View>
                  )}
                </TouchableOpacity>

                <Text style={styles.uploadInputLabel}>Selfie *</Text>
                <TouchableOpacity onPress={pickSelfieImage} style={styles.uploadImagePicker}>
                  {appSelfieImage ? (
                    <Image source={appSelfieImage} style={styles.uploadPickedImage} />
                  ) : (
                    <View style={styles.uploadImagePlaceholder}>
                      <Ionicons name="person-outline" size={48} color="#A68C7B" />
                      <Text style={styles.uploadImageText}>Tap to upload Selfie</Text>
                    </View>
                  )}
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.uploadButton, appSubmitting && styles.uploadButtonDisabled]}
                  onPress={submitArtistApplication}
                  disabled={appSubmitting}
                >
                  <Text style={styles.uploadButtonText}>
                    {appSubmitting ? 'Submitting...' : 'Submit Application'}
                  </Text>
                </TouchableOpacity>
              </ScrollView>
            </View>
          </View>
        </KeyboardAvoidingView>
      </Modal>
        <View style={styles.avatarContainer}>
          {image ? (
            <Image source={image} style={styles.avatar} />
          ) : (
            <View style={[styles.avatar, styles.placeholderCircle, { backgroundColor: "#dfe3e8" }]}>
              {getInitials() ? (
                <Text style={{ fontSize: 32, fontWeight: "bold", color: "#555" }}>
                  {getInitials()}
                </Text>
              ) : (
                <Icon name="user" size={50} color="#999" />
              )}
            </View>
          )}
        </View>


        <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'center', marginTop: -30 }}>
          <Text style={[styles.name, { marginTop: 0 }]}>{username || "Username"}</Text>
          {(String(role || '').toLowerCase() === 'artist' || String(role || '').toLowerCase() === 'admin') && (
            <Ionicons name="checkmark-circle" size={20} color="#D2AE7E" style={{ marginLeft: 6 }} />
          )}
        </View>

        <Text style={[styles.name, { fontSize: 16, color: '#666', marginTop: 5 }]}>
          {[firstName, middleName, lastName].filter(Boolean).join(' ') || "Not set"}
        </Text>

        <View style={styles.infoContainer}>
          <Text style={styles.detail}><Text style={styles.detailLabel}>Gender:</Text> {sex || "Not set"}</Text>
          <Text style={styles.detail}><Text style={styles.detailLabel}>Birthdate:</Text> {formattedDate || "Not set"}</Text>
          <Text style={styles.detail}><Text style={styles.detailLabel}>Address:</Text> {address}</Text>
          <Text style={styles.detail}><Text style={styles.detailLabel}>Bio:</Text> {bio}</Text>
        </View>

        <View style={styles.infoContainer}>
          <Text style={styles.detail}><Text style={styles.detailLabel}>About:</Text> {about}</Text>
        </View>
      </View>


      {/* Artwork Galleries - visible only to artist/admin */}
      {(String(role || '').toLowerCase() === 'artist' || String(role || '').toLowerCase() === 'admin') && (
        <>
          <View style={styles.artworkHeaderContainer}>
            <Text style={[styles.sectionTitle, { marginTop: 0, marginBottom: 0, marginHorizontal: 0 }]}>My Artwork</Text>
            <View style={styles.artworkBadge}>
              <Text style={styles.artworkBadgeText}>
                {galleryImages.length} {galleryImages.length === 1 ? 'piece' : 'pieces'}
              </Text>
            </View>
          </View>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            style={styles.galleryRow}
            decelerationRate={Platform.OS === 'ios' ? 'fast' : 0.98}
            scrollEventThrottle={16}
          >
            {galleryImages.map((art, index) => (
              <TouchableOpacity key={index} onPress={() => setSelectedArt(art)}>
                <Image 
                  source={{ uri: art.image }} 
                  style={styles.galleryItem}
                  onError={(error) => {
                    console.log('[profile.js] Gallery thumbnail error:', error.nativeEvent?.error);
                    console.log('[profile.js] Failed thumbnail URI:', art.image);
                  }}
                />
              </TouchableOpacity>
            ))}
            <TouchableOpacity style={styles.addImageBox} onPress={handleAddImage}>
              <Text style={styles.addImageText}>+</Text>
            </TouchableOpacity>
          </ScrollView>
        </>
      )}


      {/* Artwork Details Modal */}
      <Modal visible={selectedArt !== null} transparent animationType="fade" onRequestClose={() => setSelectedArt(null)}>
        <View style={styles.fullScreenContainer}>
          <View style={{ width: '90%', maxHeight: '85%', backgroundColor: '#fff', borderRadius: 12, overflow: 'hidden' }}>
            {/* Explicit close button */}
            <TouchableOpacity onPress={() => setSelectedArt(null)} style={styles.modalCloseButton}>
              <Ionicons name="close" size={24} color="white" />
            </TouchableOpacity>
            
            {/* Fixed Image at top */}
            {selectedArt?.image && (
              <Image 
                source={{ uri: selectedArt.image }} 
                style={styles.artModalImage}
                onError={(error) => {
                  console.log('[profile.js] Image load error:', error.nativeEvent?.error);
                  console.log('[profile.js] Failed image URI:', selectedArt.image);
                }}
              />
            )}
            
            {/* Scrollable content below image */}
            <ScrollView
              contentContainerStyle={{ paddingBottom: 16 }}
              decelerationRate={Platform.OS === 'ios' ? 'fast' : 0.98}
              scrollEventThrottle={16}
              showsVerticalScrollIndicator
              nestedScrollEnabled
            >
              <View style={{ padding: 12 }}>
                
                {/* Row 1: Username, Heart, and Menu */}
                <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', marginBottom: 8 }}>
                  <Text style={{ fontSize: 18, fontWeight: 'bold' }}>{username || 'Artist'}</Text>
                  
                  <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>
                    {/* Heart/Like Button */}
                    <TouchableOpacity onPress={handleToggleArtLike} style={{ flexDirection: 'row', alignItems: 'center', paddingVertical: 6, paddingHorizontal: 12, backgroundColor: '#f5f5f5', borderRadius: 20 }}>
                      <Icon name={artUserLiked ? 'heart' : 'heart-o'} size={22} color={artUserLiked ? 'red' : '#555'} />
                      <Text style={{ marginLeft: 8, fontWeight: '600' }}>{artLikesCount}</Text>
                    </TouchableOpacity>
                    
                    {/* Three-dot Menu for Edit/Delete */}
                    <View style={{ position: 'relative' }}>
                      <TouchableOpacity 
                        onPress={() => setArtMenuVisible(!artMenuVisible)}
                        style={{ padding: 8 }}
                      >
                        <Ionicons name="ellipsis-horizontal" size={24} color="#555" />
                      </TouchableOpacity>
                      
                      {/* Dropdown menu */}
                      {artMenuVisible && (
                        <View style={styles.dropdownMenu}>
                          <TouchableOpacity 
                            style={styles.menuItem}
                            onPress={() => {
                              setArtMenuVisible(false);
                              handleEditArtwork(selectedArt);
                            }}
                          >
                            <Ionicons name="pencil-outline" size={18} color="#555" />
                            <Text style={styles.menuItemText}>Edit</Text>
                          </TouchableOpacity>
                          <TouchableOpacity 
                            style={[styles.menuItem, { borderTopWidth: 1, borderTopColor: '#eee' }]}
                            onPress={() => {
                              setArtMenuVisible(false);
                              handleDeleteArtwork(selectedArt);
                            }}
                          >
                            <Ionicons name="trash-outline" size={18} color="#d9534f" />
                            <Text style={[styles.menuItemText, { color: '#d9534f' }]}>Delete</Text>
                          </TouchableOpacity>
                        </View>
                      )}
                    </View>
                  </View>
                </View>

                {/* Row 2: By: Fullname */}
                <View style={{ marginBottom: 12 }}>
                  <Text style={{ fontSize: 14, color: '#666' }}>
                    by: {[firstName, middleName, lastName].filter(Boolean).join(' ') || username || 'Unknown'}
                  </Text>
                </View>

                {/* Medium */}
                {!!selectedArt?.medium && (
                  <View style={{ marginBottom: 12 }}>
                    <Text style={{ fontSize: 14, fontWeight: '600', color: '#555', marginBottom: 4 }}>Medium:</Text>
                    <Text style={{ fontSize: 14, color: '#222' }}>{selectedArt.medium}</Text>
                  </View>
                )}

                {/* Description */}
                {!!selectedArt?.description && (
                  <View style={{ marginBottom: 8 }}>
                    <Text style={{ fontSize: 14, fontWeight: '600', color: '#555', marginBottom: 4 }}>Description:</Text>
                    <Text style={{ fontSize: 14, color: '#222' }}>
                      {descriptionExpanded || selectedArt.description.length <= 150
                        ? selectedArt.description
                        : ${selectedArt.description.substring(0, 150)}...}
                    </Text>
                    {selectedArt.description.length > 150 && (
                      <TouchableOpacity onPress={() => setDescriptionExpanded(!descriptionExpanded)} style={{ alignItems: 'center' }}>
                        <Text style={{ fontSize: 14, color: '#A68C7B', fontWeight: '600', marginTop: 4 }}>
                          {descriptionExpanded ? 'View Less' : 'View More'}
                        </Text>
                      </TouchableOpacity>
                    )}
                  </View>
                )}

                {/* Date and time */}
                {!!selectedArt?.timestamp && (
                  <Text style={{ fontSize: 12, color: '#888', marginTop: 8 }}>{selectedArt.timestamp}</Text>
                )}

                <View style={{ height: 1, backgroundColor: '#eee', marginVertical: 10 }} />
                
                {/* Comments Button */}
                <TouchableOpacity 
                  onPress={openCommentsModal}
                  style={{ 
                    flexDirection: 'row', 
                    alignItems: 'center', 
                    backgroundColor: '#f5f5f5', 
                    padding: 12, 
                    borderRadius: 8,
                    marginTop: 10
                  }}
                >
                  <Ionicons name="chatbubble-outline" size={20} color="#A68C7B" />
                  <Text style={{ marginLeft: 8, fontSize: 14, fontWeight: '600', color: '#333' }}>
                    View Comments ({(() => {
                      const count = totalCommentCount > 0 ? totalCommentCount : (artComments?.length || 0);
                      return count >= 10 ? '10+' : count;
                    })()})
                  </Text>
                </TouchableOpacity>
              </View>
            </ScrollView>
          </View>
        </View>
      </Modal>

      {/* Edit Artwork Modal */}
      <Modal
        visible={editModalVisible}
        animationType="slide"
        transparent
        onRequestClose={() => setEditModalVisible(false)}
      >
        <KeyboardAvoidingView 
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <View style={styles.uploadModalOverlay}>
            <View style={styles.uploadModalContent}>
              <View style={styles.uploadModalHeader}>
                <Text style={styles.uploadModalTitle}>Edit Artwork</Text>
                <TouchableOpacity onPress={() => setEditModalVisible(false)}>
                  <Ionicons name="close" size={24} color="#333" />
                </TouchableOpacity>
              </View>

              <ScrollView style={styles.uploadModalBody} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
                {/* Image Picker */}
                <TouchableOpacity style={styles.uploadImagePicker} onPress={pickEditArtworkImage}>
                  {editArtImage ? (
                    <Image source={editArtImage} style={styles.uploadPickedImage} />
                  ) : (
                    <View style={styles.uploadImagePlaceholder}>
                      <Ionicons name="image-outline" size={48} color="#A68C7B" />
                      <Text style={styles.uploadImageText}>{editingArt ? 'Tap to change image (keep current or select new)' : 'Tap to select image'}</Text>
                    </View>
                  )}
                </TouchableOpacity>

                {/* Title Input */}
                <Text style={styles.uploadInputLabel}>Title *</Text>
                <TextInput
                  style={styles.uploadInput}
                  placeholder="Enter artwork title"
                  value={editArtTitle}
                  onChangeText={setEditArtTitle}
                />

                {/* Medium Input */}
                <Text style={styles.uploadInputLabel}>Medium</Text>
                <TextInput
                  style={styles.uploadInput}
                  placeholder="e.g., Oil, Digital, Watercolor"
                  value={editArtMedium}
                  onChangeText={setEditArtMedium}
                />

                {/* Description Input */}
                <Text style={styles.uploadInputLabel}>Description</Text>
                <TextInput
                  style={[styles.uploadInput, styles.uploadTextArea]}
                  placeholder="Enter description"
                  value={editArtDescription}
                  onChangeText={setEditArtDescription}
                  multiline
                  numberOfLines={4}
                />

                {/* Update Button */}
                <TouchableOpacity
                  style={[styles.uploadButton, editArtUploading && styles.uploadButtonDisabled]}
                  onPress={submitEditArtwork}
                  disabled={editArtUploading}
                >
                  <Text style={styles.uploadButtonText}>
                    {editArtUploading ? 'Updating...' : 'Update Artwork'}
                  </Text>
                </TouchableOpacity>
              </ScrollView>
            </View>
          </View>
        </KeyboardAvoidingView>
      </Modal>

      {/* Comments Modal - Home.js Style */}
      <Modal 
        visible={commentsModalVisible} 
        animationType="slide"
        onRequestClose={closeCommentsModal}
      >
        <View style={{ flex: 1, backgroundColor: '#f5f5f5', paddingTop: Platform.OS === 'android' ? 8 : 0 }}>
          {/* Header - Fixed at top */}
          <View style={{ 
            flexDirection: 'row', 
            alignItems: 'center', 
            paddingHorizontal: 10, 
            paddingTop: 2,
            paddingBottom: 6,
            backgroundColor: '#f5f5f5', 
            borderBottomWidth: 1, 
            borderBottomColor: '#e0e0e0' 
          }}>
            <TouchableOpacity onPress={closeCommentsModal}>
              <Ionicons name="arrow-back" size={24} color="#000" />
            </TouchableOpacity>
            <Text style={{ fontSize: 18, fontWeight: 'bold', marginLeft: 10 }}>Comments</Text>
          </View>
          
          {/* Comments List - Static, never moves with keyboard */}
          <View style={{ flex: 1, marginBottom: 60 }}>
            <FlatList
              data={artComments || []}
              keyExtractor={(item) => String(item.id)}
              renderItem={renderArtComment}
              keyboardShouldPersistTaps="handled"
              ListEmptyComponent={
                <View style={styles.emptyCommentsContainer}>
                  <Ionicons name="chatbubbles-outline" size={64} color="#A68C7B" style={{ marginBottom: 12 }} />
                  <Text style={styles.emptyCommentsText}>No comments yet</Text>
                  <Text style={styles.emptyCommentsSubtext}>Be the first to comment!</Text>
                </View>
              }
              ListFooterComponent={
                (artComments || []).length > 0 ? (
                  <View>
                    {commentPage > 1 && (
                      <TouchableOpacity 
                        style={[styles.loadMoreCommentsButton, { backgroundColor: '#fff' }]} 
                        onPress={showLessArtComments}
                      >
                        <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                          <Text style={styles.loadMoreCommentsText}>Show Less</Text>
                          <Ionicons name="chevron-up" size={16} color="#A68C7B" style={{ marginLeft: 4 }} />
                        </View>
                      </TouchableOpacity>
                    )}
                    {hasMoreComments && (
                      <TouchableOpacity 
                        style={styles.loadMoreCommentsButton} 
                        onPress={loadMoreArtComments}
                        disabled={loadingMoreComments}
                      >
                        {loadingMoreComments ? (
                          <ActivityIndicator size="small" color="#A68C7B" />
                        ) : (
                          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                            <Text style={styles.loadMoreCommentsText}>Load More Comments</Text>
                            <Ionicons name="chevron-down" size={16} color="#A68C7B" style={{ marginLeft: 4 }} />
                          </View>
                        )}
                      </TouchableOpacity>
                    )}
                  </View>
                ) : null
              }
              contentContainerStyle={
                (artComments || []).length === 0 ? { flex: 1 } : { paddingVertical: 16 }
              }
            />
          </View>
          
          {/* Input Container - Absolutely positioned, only this moves with keyboard */}
          <KeyboardAvoidingView
            behavior="padding"
            keyboardVerticalOffset={0}
            style={{ position: 'absolute', bottom: 0, left: 0, right: 0 }}
          >
            <View style={styles.commentInputContainer}>
              <TextInput
                style={styles.commentInput}
                placeholder="Add a comment..."
                placeholderTextColor="#999"
                value={artNewComment}
                onChangeText={setArtNewComment}
              />
              <TouchableOpacity onPress={postArtComment} style={styles.sendButton}>
                <Ionicons name="send" size={20} color="white" />
              </TouchableOpacity>
            </View>
          </KeyboardAvoidingView>
        </View>
      </Modal>

      {/* Artwork Upload Modal */}
      <Modal
        visible={artModalVisible}
        animationType="slide"
        transparent
        onRequestClose={() => setArtModalVisible(false)}
      >
        <KeyboardAvoidingView 
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <View style={styles.uploadModalOverlay}>
            <View style={styles.uploadModalContent}>
              <View style={styles.uploadModalHeader}>
                <Text style={styles.uploadModalTitle}>Upload Artwork</Text>
                <TouchableOpacity onPress={() => setArtModalVisible(false)}>
                  <Ionicons name="close" size={24} color="#333" />
                </TouchableOpacity>
              </View>

              <ScrollView style={styles.uploadModalBody} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
              {/* Image Picker */}
              <TouchableOpacity style={styles.uploadImagePicker} onPress={pickArtworkImage}>
                {artImage ? (
                  <Image source={artImage} style={styles.uploadPickedImage} />
                ) : (
                  <View style={styles.uploadImagePlaceholder}>
                    <Ionicons name="image-outline" size={48} color="#A68C7B" />
                    <Text style={styles.uploadImageText}>Tap to select image</Text>
                  </View>
                )}
              </TouchableOpacity>

              {/* Title Input */}
              <Text style={styles.uploadInputLabel}>Title *</Text>
              <TextInput
                style={styles.uploadInput}
                placeholder="Enter artwork title"
                value={artTitle}
                onChangeText={setArtTitle}
              />

              {/* Medium Input */}
              <Text style={styles.uploadInputLabel}>Medium</Text>
              <TextInput
                style={styles.uploadInput}
                placeholder="e.g., Oil, Digital, Watercolor"
                value={artMedium}
                onChangeText={setArtMedium}
              />

              {/* Description Input */}
              <Text style={styles.uploadInputLabel}>Description</Text>
              <TextInput
                style={[styles.uploadInput, styles.uploadTextArea]}
                placeholder="Enter description"
                value={artDescription}
                onChangeText={setArtDescription}
                multiline
                numberOfLines={4}
              />

              {/* Watermark Section */}
              <View style={styles.watermarkSection}>
                <TouchableOpacity 
                  style={styles.checkboxContainer}
                  onPress={() => setArtApplyWatermark(!artApplyWatermark)}
                >
                  <Ionicons 
                    name={artApplyWatermark ? 'checkbox' : 'square-outline'} 
                    size={24} 
                    color="#A68C7B" 
                  />
                  <View style={styles.checkboxLabel}>
                    <Text style={styles.checkboxTitle}> Protect with watermark</Text>
                    <Text style={styles.checkboxSubtitle}>
                      Add watermark to protect your artwork from unauthorized use
                    </Text>
                  </View>
                </TouchableOpacity>

                {artApplyWatermark && (
                  <View style={styles.watermarkInputContainer}>
                    <Text style={styles.watermarkInputLabel}>
                      Custom watermark text (optional)
                    </Text>
                    <TextInput
                      style={styles.watermarkInput}
                      placeholder={ Your Name ${new Date().getFullYear()}  Museo}
                      value={artWatermarkText}
                      onChangeText={setArtWatermarkText}
                    />
                    <Text style={styles.watermarkHint}>
                      Leave blank to use default watermark
                    </Text>
                  </View>
                )}
              </View>

              {/* Upload Button */}
              <TouchableOpacity
                style={[styles.uploadButton, artUploading && styles.uploadButtonDisabled]}
                onPress={submitArtwork}
                disabled={artUploading}
              >
                <Text style={styles.uploadButtonText}>
                  {artUploading ? 'Uploading...' : 'Upload Artwork'}
                </Text>
              </TouchableOpacity>
            </ScrollView>
          </View>
        </View>
        </KeyboardAvoidingView>
      </Modal>


      {/* Edit Profile Modal */}
      <Modal visible={modalVisible} animationType="slide" transparent onRequestClose={() => setModalVisible(false)}>
        <KeyboardAvoidingView 
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <View style={styles.uploadModalOverlay}>
            <View style={styles.uploadModalContent}>
              <View style={styles.uploadModalHeader}>
                <Text style={styles.uploadModalTitle}>Edit Profile</Text>
                <TouchableOpacity onPress={() => setModalVisible(false)}>
                  <Ionicons name="close" size={24} color="#333" />
                </TouchableOpacity>
              </View>

              <ScrollView style={styles.uploadModalBody} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
                <Text style={styles.uploadInputLabel}>Profile Photo</Text>
                <TouchableOpacity onPress={pickImage} style={styles.uploadImagePicker}>
                  {tempImage ? (
                    <Image source={tempImage} style={styles.uploadPickedImage} />
                  ) : (
                    <View style={styles.uploadImagePlaceholder}>
                      <Ionicons name="person-circle-outline" size={48} color="#A68C7B" />
                      <Text style={styles.uploadImageText}>Tap to change photo</Text>
                    </View>
                  )}
                </TouchableOpacity>

                <Text style={styles.uploadInputLabel}>Cover Photo</Text>
                <TouchableOpacity onPress={pickBackgroundImage} style={styles.uploadImagePicker}>
                  {tempBackgroundImage ? (
                    <Image source={{ uri: tempBackgroundImage.uri }} style={styles.uploadPickedImage} />
                  ) : (
                    <View style={styles.uploadImagePlaceholder}>
                      <Ionicons name="image-outline" size={48} color="#A68C7B" />
                      <Text style={styles.uploadImageText}>Tap to change cover</Text>
                    </View>
                  )}
                </TouchableOpacity>

                <Text style={styles.uploadInputLabel}>First Name</Text>
                <TextInput style={styles.uploadInput} placeholder="First Name" value={tempFirstName} onChangeText={setTempFirstName} />

                <Text style={styles.uploadInputLabel}>Middle Name</Text>
                <TextInput style={styles.uploadInput} placeholder="Middle Name" value={tempMiddleName} onChangeText={setTempMiddleName} />

                <Text style={styles.uploadInputLabel}>Last Name</Text>
                <TextInput style={styles.uploadInput} placeholder="Last Name" value={tempLastName} onChangeText={setTempLastName} />

                <Text style={styles.uploadInputLabel}>Username</Text>
                <TextInput style={styles.uploadInput} placeholder="Username" value={tempUserNameField} onChangeText={setTempUserNameField} />

                <Text style={styles.uploadInputLabel}>Sex</Text>
                <TouchableOpacity style={styles.uploadInput} onPress={() => setShowSexDropdown(!showSexDropdown)}>
                  <Text style={{ color: tempSex ? "#000" : "#999" }}>{tempSex || "Select Sex"}</Text>
                  <Ionicons name={showSexDropdown ? "chevron-up" : "chevron-down"} size={20} color="#555" style={{ position: "absolute", right: 12, top: 12 }} />
                </TouchableOpacity>
                {showSexDropdown && (
                  <View style={styles.categoryDropdown}>
                    {["Male", "Female", "PreferNotToSay"].map((item) => (
                      <TouchableOpacity key={item} style={styles.categoryItem} onPress={() => { setTempSex(item); setShowSexDropdown(false); }}>
                        <Text style={styles.categoryItemText}>{item}</Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}

                <Text style={styles.uploadInputLabel}>Birthday</Text>
                <TouchableOpacity style={styles.uploadInput} onPress={() => setShowDatePicker(true)}>
                  <Text style={{ color: tempBirthday ? "#000" : "#999" }}>
                    {tempBirthday ? formattedTempDate : "Select your birthday"}
                  </Text>
                </TouchableOpacity>
                {showDatePicker && (
                  <DateTimePicker value={tempBirthday} mode="date" display="default" onChange={onChangeTempDate} />
                )}

                <Text style={styles.uploadInputLabel}>Address</Text>
                <TextInput style={styles.uploadInput} placeholder="Enter your address" value={tempAddress} onChangeText={setTempAddress} />

                <Text style={styles.uploadInputLabel}>Bio</Text>
                <TextInput style={styles.uploadInput} placeholder="Enter your bio" value={tempBio} onChangeText={setTempBio} />

                <Text style={styles.uploadInputLabel}>About</Text>
                <TextInput style={[styles.uploadInput, styles.uploadTextArea]} placeholder="Write something about yourself" multiline value={tempAbout} onChangeText={setTempAbout} />

                <TouchableOpacity style={styles.uploadButton} onPress={handleSave}>
                  <Text style={styles.uploadButtonText}>Save Changes</Text>
                </TouchableOpacity>
              </ScrollView>
            </View>
          </View>
        </KeyboardAvoidingView>
      </Modal>
      </ScrollView>
      <AndroidFooterSpacer />
    </SafeAreaView>
  );
}


const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    backgroundColor: "#fff" 
  },
  scrollContent: { 
    flex: 1 
  },
  profileSection: { 
    alignItems: "center", 
    marginTop: 10, 
    padding: 0 
  },
  backgroundImage: {
    width: "100%",
    height: 150,
    borderTopLeftRadius: 15,
    borderTopRightRadius: 15,
    resizeMode: "cover",
    marginBottom: -50,
  },
  avatarContainer: { 
    position: "relative", 
    top: -50, 
    alignItems: "center" 
  },
  avatar: {
    width: 100,
    height: 100,
    borderRadius: 50,
    borderWidth: 3,
    borderColor: "#fff",
  },
  name: { 
    fontSize: 20, 
    fontWeight: "bold", 
    marginTop: -30 
  },
  detail: { 
    fontSize: 14, 
    color: "#000", 
    textAlign: "center", 
    marginVertical: 2 
  },
  detailLabel: { 
    color: "#A68C7B", 
    fontWeight: "600" 
  },
  infoContainer: {
    backgroundColor: "#f9f9f9",
    borderWidth: 1,
    borderColor: "#D2AE7E",
    borderRadius: 10,
    padding: 12,
    marginVertical: 10,
    marginHorizontal: 20,
    width: "90%",
  },
  buttonContainer: { 
    alignItems: "center", 
    marginTop: 10 
  },
  buttonRow: { flexDirection: "row" },
  button: {
    backgroundColor: "#A68C7B",
    paddingVertical: 8,
    paddingHorizontal: 20,
    borderRadius: 20,
    marginHorizontal: 5,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
  },
  buttonText: { 
    fontSize: 14, 
    fontWeight: "600", 
    color: "#fff" 
  },
  fullWidthButton: {
    marginTop: 10,
    alignSelf: "stretch",
    marginHorizontal: 5,
    alignItems: "center",
    justifyContent: "center",
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: "bold",
    marginHorizontal: 15,
    marginTop: 25,
    marginBottom: 10,
  },
  artworkHeaderContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginHorizontal: 15,
    marginTop: 25,
    marginBottom: 10,
  },
  artworkBadge: {
    backgroundColor: '#A68C7B',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    marginLeft: 8,
  },
  artworkBadgeText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
  galleryRow: { 
    flexDirection: "row", 
    paddingHorizontal: 10 
  },
  galleryItem: {
    width: 180,
    height: 150,
    borderRadius: 10,
    marginRight: 10,
  },
  artworkPreview: {
    width: 150,
    height: 150,
    borderRadius: 12,
    backgroundColor: '#f0f0f0',
  },
  addImageBox: {
    width: 150,
    height: 150,
    borderRadius: 10,
    borderWidth: 2,
    borderColor: "#D2AE7E",
    alignItems: "center",
    justifyContent: "center",
    marginRight: 10,
  },
  addImageText: { 
    fontSize: 32, 
    color: "#D2AE7E" 
  },
  fullScreenContainer: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.9)",
    justifyContent: "center",
    alignItems: "center",
  },
  fullScreenImage: { width: "90%", height: "80%" },
  modalOverlay: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "rgba(0,0,0,0.4)",
  },
  keyboardView: { flex: 1, width: "100%" },
  modalBox: {
    backgroundColor: "#fff",
    padding: 20,
    borderRadius: 15,
    elevation: 5,
    alignItems: "center",
    
  },
  modalTitle: { 
    fontSize: 18, 
    fontWeight: "bold", 
    marginTop: 30, 
    marginBottom: 15 
  },
  imagePicker: { 
    alignItems: "center", 
    marginVertical: 10 
  },
  avatarEdit: { 
    width: 90, 
    height: 90, 
    borderRadius: 45 
  },
  changePhotoText: { 
    textAlign: "center", 
    color: "#007BFF", 
    marginTop: 5, 
    marginBottom: 10 
  },
  input: {
    backgroundColor: "#f9f9f9",
    borderWidth: 1,
    borderColor: "#ccc",
    borderRadius: 10,
    padding: 10,
    marginVertical: 5,
    width: "100%",
  },
  inputContainer: { 
    width: "100%", 
    position: "relative" 
  },
  dropdownList: {
    width: "100%",
    backgroundColor: "#fff",
    borderWidth: 1,
    borderColor: "#ccc",
    borderRadius: 10,
    marginTop: -5,
    elevation: 3,
    zIndex: 10,
  },
  dropdownItem: {
    paddingVertical: 12,
    paddingHorizontal: 10,
    borderBottomWidth: 1,
    borderBottomColor: "#eee",
  },
  dropdownItemText: { 
    fontSize: 16, 
    color: "#000" 
  },
  modalButtons: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 15,
    width: "100%",
  },
  saveButton: {
    backgroundColor: "#A68C7B",
    paddingVertical: 8,
    paddingHorizontal: 25,
    borderRadius: 20,
  },
  saveButtonText: { 
    color: "#fff", 
    fontWeight: "bold" 
  },
  cancelButton: {
    backgroundColor: "#eee",
    paddingVertical: 8,
    paddingHorizontal: 25,
    borderRadius: 20,
  },
  cancelButtonText: { 
    color: "black", 
    fontWeight: "bold" 
  },
  placeholderCircle: {
    backgroundColor: "#f0f0f0",
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#ddd",
  },
  backgroundPreviewContainer: {
    width: 300,
    height: 100,
    borderRadius: 10,
    overflow: "hidden",
    backgroundColor: "#f0f0f0",
    justifyContent: "center",
    alignItems: "center",
    alignSelf: "center",
  },
  backgroundPreviewImage: { 
    width: "100%", 
    height: "100%" 
  },
  artModalImage: {
    width: '100%',
    height: 260,
    resizeMode: 'cover',
    borderWidth: 3, 
    borderColor: '#fff', 
    borderRadius: 10, 
  },
  validIdPreview: {
    width: 200,        
    height: 120,       
    borderRadius: 12,
    backgroundColor: '#f0f0f0',
  },
  modalCloseButton: {
    position: 'absolute',
    top: 8,
    right: 8,
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: 'rgba(0,0,0,0.6)',
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 2,
  },
  pendingButton: {
    backgroundColor: '#FFC107',
    opacity: 0.8,
  },
  uploadModalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'flex-end',
  },
  uploadModalContent: {
    backgroundColor: '#fff',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    maxHeight: '90%',
  },
  uploadModalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  uploadModalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#A68C7B',
  },
  uploadModalBody: {
    padding: 20,
  },
  uploadImagePicker: {
    width: '100%',
    height: 200,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: '#A68C7B',
    borderStyle: 'dashed',
    marginBottom: 20,
    overflow: 'hidden',
  },
  uploadImagePlaceholder: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f9f9f9',
  },
  uploadImageText: {
    marginTop: 10,
    fontSize: 14,
    color: '#A68C7B',
  },
  uploadPickedImage: {
    width: '100%',
    height: '100%',
    resizeMode: 'cover',
  },
  uploadInputLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  uploadInput: {
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 8,
    padding: 12,
    fontSize: 14,
    marginBottom: 16,
    backgroundColor: '#fff',
  },
  uploadTextArea: {
    height: 100,
    textAlignVertical: 'top',
  },
  watermarkSection: {
    marginVertical: 16,
    paddingVertical: 12,
    paddingHorizontal: 12,
    backgroundColor: '#f9f9f9',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#e0e0e0',
  },
  checkboxContainer: {
    flexDirection: 'row',
    alignItems: 'flex-start',
  },
  checkboxLabel: {
    flex: 1,
    marginLeft: 12,
  },
  checkboxTitle: {
    fontSize: 15,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  checkboxSubtitle: {
    fontSize: 13,
    color: '#666',
    lineHeight: 18,
  },
  watermarkInputContainer: {
    marginTop: 16,
    paddingLeft: 36,
  },
  watermarkInputLabel: {
    fontSize: 13,
    color: '#555',
    marginBottom: 8,
    fontWeight: '500',
  },
  watermarkInput: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 6,
    padding: 10,
    fontSize: 14,
    color: '#333',
  },
  watermarkHint: {
    fontSize: 12,
    color: '#999',
    marginTop: 6,
  },
  uploadButton: {
    backgroundColor: '#A68C7B',
    paddingVertical: 15,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 10,
    marginBottom: 20,
  },
  uploadButtonDisabled: {
    opacity: 0.6,
  },
  uploadButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  categoryDropdown: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 8,
    marginTop: -8,
    marginBottom: 16,
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  categoryItem: {
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  categoryItemText: {
    fontSize: 14,
    color: '#333',
  },
  commentInputContainer: { 
    flexDirection: 'row', 
    padding: 10, 
    borderTopWidth: 1, 
    borderColor: '#eee',
    backgroundColor: '#f5f5f5'
  },
  commentInput: { 
    flex: 1, 
    backgroundColor: '#f0f2f5', 
    borderRadius: 20, 
    paddingHorizontal: 12 
  },
  sendButton: { 
    backgroundColor: '#A68C7B', 
    borderRadius: 20, 
    padding: 10, 
    marginLeft: 8 
  },
  emptyCommentsContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  emptyCommentsText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#666',
  },
  emptyCommentsSubtext: {
    fontSize: 14,
    color: '#999',
    marginTop: 4,
  },
  loadMoreCommentsButton: {
    backgroundColor: '#f5f5f5',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
    marginHorizontal: 16,
    marginTop: 8,
    marginBottom: 8,
  },
  loadMoreCommentsText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#A68C7B',
  },
  dropdownMenu: {
    position: 'absolute',
    top: 40,
    right: 0,
    backgroundColor: '#fff',
    borderRadius: 8,
    minWidth: 120,
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    zIndex: 1000,
  },
  menuItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  menuItemText: {
    marginLeft: 12,
    fontSize: 14,
    fontWeight: '500',
    color: '#555',
  },
});

Settings.js
import React, { useState, useEffect } from "react";
import { View, Text, StyleSheet, TouchableOpacity, ScrollView, Modal, TextInput, Platform, KeyboardAvoidingView, Alert, SafeAreaView, Image } from "react-native";
import * as ImagePicker from "expo-image-picker";
import { useFocusEffect, useRouter } from "expo-router";
import AsyncStorage from "@react-native-async-storage/async-storage";
import DateTimePicker from "@react-native-community/datetimepicker";
import Header from "../components/Header";
import { Ionicons } from '@expo/vector-icons';
import { supabase } from "../../supabase/supabaseClient";
import { useUser } from "../contexts/UserContext";
import AndroidFooterSpacer from '../components/Footer';

const API_BASE = "http://192.168.18.22:3000/api";
const API_ORIGIN = API_BASE.replace(/\/api$/, "");

export default function SettingsScreen() {
  const { userData, refreshUserData } = useUser();
  const role = userData?.role || null;
  const router = useRouter();

  // Profile state
  const [firstName, setFirstName] = useState("");
  const [middleName, setMiddleName] = useState("");
  const [lastName, setLastName] = useState("");
  const [userNameField, setUserNameField] = useState("");
  const [username, setUsername] = useState("");
  const [sex, setSex] = useState("");
  const [birthday, setBirthday] = useState(new Date());
  const [address, setAddress] = useState("");
  const [bio, setBio] = useState("");
  const [about, setAbout] = useState("");
  const [image, setImage] = useState(null);
  const [backgroundImage, setBackgroundImage] = useState(null);
  const [accessToken, setAccessToken] = useState(null);
  const [refreshToken, setRefreshToken] = useState(null);

  // Notification states
  const [marketingEmails, setMarketingEmails] = useState(true);
  const [orderUpdates, setOrderUpdates] = useState(true);
  const [newFollowers, setNewFollowers] = useState(true);
  const [commentsLikes, setCommentsLikes] = useState(true);
  
  // Notifications list
  const [notifications, setNotifications] = useState([]);
  const [showAllNotifications, setShowAllNotifications] = useState(false);
  const [loadingNotifications, setLoadingNotifications] = useState(false);
  
  // Collapsible sections
  const [accountExpanded, setAccountExpanded] = useState(true);
  const [notificationsExpanded, setNotificationsExpanded] = useState(true);
  const [marketplaceExpanded, setMarketplaceExpanded] = useState(true);

  // Privacy states
  const [profileVisibility, setProfileVisibility] = useState('public');
  const [showActivityStatus, setShowActivityStatus] = useState(true);
  const [showVisibilityDropdown, setShowVisibilityDropdown] = useState(false);

  // Marketplace states
  const [commissionRate, setCommissionRate] = useState('15');
  const [acceptCustomOrders, setAcceptCustomOrders] = useState(true);
  const [internationalShipping, setInternationalShipping] = useState(false);
  const [vacationMode, setVacationMode] = useState(false);

  // Edit Profile modal state
  const [modalVisible, setModalVisible] = useState(false);
  const [tempImage, setTempImage] = useState(null);
  const [tempBackgroundImage, setTempBackgroundImage] = useState(null);
  const [tempFirstName, setTempFirstName] = useState("");
  const [tempMiddleName, setTempMiddleName] = useState("");
  const [tempLastName, setTempLastName] = useState("");
  const [tempUserNameField, setTempUserNameField] = useState("");
  const [tempSex, setTempSex] = useState("");
  const [tempBirthday, setTempBirthday] = useState(new Date());
  const [tempAddress, setTempAddress] = useState("");
  const [tempBio, setTempBio] = useState("");
  const [tempAbout, setTempAbout] = useState("");
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [showSexDropdown, setShowSexDropdown] = useState(false);

  // Apply as Artist modal state
  const [applyModalVisible, setApplyModalVisible] = useState(false);
  const [appFirstName, setAppFirstName] = useState("");
  const [appMiddleInitial, setAppMiddleInitial] = useState("");
  const [appLastName, setAppLastName] = useState("");
  const [appPhone, setAppPhone] = useState("");
  const [appAge, setAppAge] = useState("");
  const [appSex, setAppSex] = useState("");
  const [appBirthdate, setAppBirthdate] = useState(new Date());
  const [appShowSexDropdown, setAppShowSexDropdown] = useState(false);
  const [appShowDatePicker, setAppShowDatePicker] = useState(false);
  const [appAddress, setAppAddress] = useState("");
  const [appValidIdImage, setAppValidIdImage] = useState(null);
  const [appSelfieImage, setAppSelfieImage] = useState(null);
  const [appSubmitting, setAppSubmitting] = useState(false);
  const [hasPendingRequest, setHasPendingRequest] = useState(false);

  // Apply as Seller modal state (3-step wizard)
  const [sellerModalVisible, setSellerModalVisible] = useState(false);
  const [sellerCurrentStep, setSellerCurrentStep] = useState(1);
  const [sellerSubmitting, setSellerSubmitting] = useState(false);
  const [hasPendingSellerRequest, setHasPendingSellerRequest] = useState(false);
  
  // Step 1: Basic Information
  const [shopName, setShopName] = useState("");
  const [sellerFullName, setSellerFullName] = useState("");
  const [sellerEmail, setSellerEmail] = useState("");
  const [sellerPhone, setSellerPhone] = useState("");
  
  // Step 2: Business Address (PSGC)
  const [street, setStreet] = useState("");
  const [landmark, setLandmark] = useState("");
  const [regions, setRegions] = useState([]);
  const [provinces, setProvinces] = useState([]);
  const [cities, setCities] = useState([]);
  const [barangays, setBarangays] = useState([]);
  const [selectedRegion, setSelectedRegion] = useState("");
  const [selectedProvince, setSelectedProvince] = useState("");
  const [selectedCity, setSelectedCity] = useState("");
  const [selectedBarangay, setSelectedBarangay] = useState("");
  const [postalCode, setPostalCode] = useState("");
  const [showRegionDropdown, setShowRegionDropdown] = useState(false);
  const [showProvinceDropdown, setShowProvinceDropdown] = useState(false);
  const [showCityDropdown, setShowCityDropdown] = useState(false);
  const [showBarangayDropdown, setShowBarangayDropdown] = useState(false);
  
  // Step 3: Verification & Terms
  const [shopDescription, setShopDescription] = useState("");
  const [sellerIdDocument, setSellerIdDocument] = useState(null);
  const [agreedToTerms, setAgreedToTerms] = useState(false);
  const [sellerApplicationStatus, setSellerApplicationStatus] = useState(null); // 'pending', 'approved', 'rejected'

  useEffect(() => {
    const init = async () => {
      try {
        const { data } = await supabase.auth.getSession();
        const at = data?.session?.access_token || null;
        const rt = data?.session?.refresh_token || null;
        setAccessToken(at);
        setRefreshToken(rt);

        if (at && rt) {
          await refreshUserData();
          await fetchProfile(at, rt);
          await checkPendingRequest(at, rt);
        }
      } catch (e) {
        console.warn("Settings init error:", e?.message || e);
      }
    };
    init();
  }, []);

  // Refresh profile data when screen comes into focus
  useFocusEffect(
    React.useCallback(() => {
      const refresh = async () => {
        try {
          const { data } = await supabase.auth.getSession();
          const at = data?.session?.access_token || null;
          const rt = data?.session?.refresh_token || null;
          
          if (at && rt) {
            await refreshUserData();
            await fetchProfile(at, rt);
            await checkPendingRequest(at, rt);
          }
        } catch (e) {
          console.warn("Settings focus refresh error:", e?.message || e);
        }
      };
      refresh();
      return () => {};
    }, [])
  );

  const fetchProfile = async (at = accessToken, rt = refreshToken) => {
    try {
      const res = await fetch(${API_BASE}/profile/getProfile, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Cookie: access_token=${at}; refresh_token=${rt},
        },
      });
      if (!res.ok) throw new Error(Failed to fetch profile (${res.status}));

      const data = await res.json();
      const p = data?.profile ?? data;

      setFirstName(p.firstName || "");
      setMiddleName(p.middleName || "");
      setLastName(p.lastName || "");
      setUserNameField(p.username || "");
      setUsername(p.username || "");
      setSex(p.sex || "");
      setAddress(p.address || "");
      setBio(p.bio || "");
      setAbout(p.about || "");

      const fetchedBday = p.birthday || p.birthdate;
      if (fetchedBday) {
        const parsedDate = new Date(fetchedBday);
        setBirthday(parsedDate);
        await AsyncStorage.setItem("userBirthday", parsedDate.toISOString());
      }

      const resolveUrl = (u) => {
        if (!u) return null;
        return u.startsWith("http") ? u : ${API_ORIGIN}${u};
      };
      const avatarUrl = resolveUrl(p.profilePicture);
      const coverUrl = resolveUrl(p.coverPicture);
      setImage(avatarUrl ? { uri: avatarUrl } : null);
      setBackgroundImage(coverUrl ? { uri: coverUrl } : null);
    } catch (err) {
      console.warn("Profile fetch failed:", err.message);
    }
  };

  const checkPendingRequest = async (at, rt) => {
    try {
      const res = await fetch(${API_BASE}/request/getRequest, {
        method: "GET",
        credentials: "include",
        headers: {
          Cookie: access_token=${at}; refresh_token=${rt},
        },
      });
      if (!res.ok) {
        setHasPendingRequest(false);
        return false;
      }
      const data = await res.json();
      
      if (data?.requests && Array.isArray(data.requests)) {
        const pendingArtistRequest = data.requests.find(
          req => req.requestType === 'artist_verification' && req.status === 'pending'
        );
        const hasPending = !!pendingArtistRequest;
        setHasPendingRequest(hasPending);
        return hasPending;
      }
      setHasPendingRequest(false);
      return false;
    } catch (error) {
      console.error("Error checking pending request:", error?.message || error);
      setHasPendingRequest(false);
      return false;
    }
  };

  const pickImage = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [1, 1],
      quality: 1,
    });
    if (!result.canceled) {
      setTempImage({ uri: result.assets[0].uri });
    }
  };

  const pickBackgroundImage = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [16, 9],
      quality: 1,
    });
    if (!result.canceled) {
      setTempBackgroundImage({ uri: result.assets[0].uri });
    }
  };

  const onChangeTempDate = (event, selectedDate) => {
    if (selectedDate) setTempBirthday(selectedDate);
    if (Platform.OS === 'android') setShowDatePicker(false);
  };

  const handleSave = async () => {
    try {
      const formData = new FormData();
      if (tempImage) {
        const filename = tempImage.uri.split("/").pop();
        const match = /\.(\w+)$/.exec(filename);
        const type = match ? image/${match[1]} : "image";
        formData.append("avatar", { uri: tempImage.uri, name: filename, type });
      }
      if (tempBackgroundImage) {
        const filename = tempBackgroundImage.uri.split("/").pop();
        const match = /\.(\w+)$/.exec(filename);
        const type = match ? image/${match[1]} : "image";
        formData.append("cover", { uri: tempBackgroundImage.uri, name: filename, type });
      }

      formData.append("firstName", String(tempFirstName ?? ""));
      formData.append("middleName", String(tempMiddleName ?? ""));
      formData.append("lastName", String(tempLastName ?? ""));
      formData.append("username", String(tempUserNameField || username || ""));
      formData.append("sex", String(tempSex ?? ""));
      const birthdayISO = tempBirthday ? new Date(tempBirthday).toISOString() : "";
      formData.append("birthday", birthdayISO);
      formData.append("birthdate", birthdayISO);
      formData.append("address", String(tempAddress ?? ""));
      formData.append("bio", String(tempBio ?? ""));
      formData.append("about", String(tempAbout ?? ""));

      if (tempBirthday) {
        await AsyncStorage.setItem("userBirthday", new Date(tempBirthday).toISOString());
      }

      const res = await fetch(${API_BASE}/profile/updateProfile, {
        method: "POST",
        headers: {
          Cookie: access_token=${accessToken}; refresh_token=${refreshToken},
        },
        body: formData,
      });

      if (!res.ok) {
        let errorMsg = "Failed to update profile";
        try {
          const errorData = await res.json();
          errorMsg = errorData?.message || errorData?.error || errorMsg;
        } catch {}
        throw new Error(errorMsg);
      }

      setModalVisible(false);
      setTempImage(null);
      setTempBackgroundImage(null);
      await fetchProfile();
      await refreshUserData();

      Alert.alert("Success", "Profile updated successfully!");
    } catch (err) {
      console.error("Profile update error:", err);
      Alert.alert("Update Failed", err?.message || "Failed to save profile information");
    }
  };

  const pickValidIdImage = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [4, 3],
      quality: 1,
    });
    if (!result.canceled) {
      setAppValidIdImage({ uri: result.assets[0].uri });
    }
  };

  const pickSelfieImage = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [1, 1],
      quality: 1,
    });
    if (!result.canceled) {
      setAppSelfieImage({ uri: result.assets[0].uri });
    }
  };

  const onChangeAppDate = (event, selectedDate) => {
    if (selectedDate) setAppBirthdate(selectedDate);
    if (Platform.OS === 'android') setAppShowDatePicker(false);
  };

  const submitArtistApplication = async () => {
    try {
      if (!appFirstName || !appLastName || !appPhone || !appAge || !appSex || !appBirthdate || !appAddress || !appValidIdImage || !appSelfieImage) {
        Alert.alert('Incomplete', 'Please fill in all fields and attach both images.');
        return;
      }
      setAppSubmitting(true);

      let at = accessToken, rt = refreshToken;
      if (!at || !rt) {
        const { data } = await supabase.auth.getSession();
        at = data?.session?.access_token || at;
        rt = data?.session?.refresh_token || rt;
      }

      const fd = new FormData();
      fd.append('requestType', 'artist_verification');
      fd.append('firstName', String(appFirstName));
      fd.append('midInit', String(appMiddleInitial || ''));
      fd.append('lastName', String(appLastName));
      fd.append('phone', String(appPhone));
      fd.append('age', String(appAge));
      fd.append('sex', String(appSex));
      fd.append('birthdate', new Date(appBirthdate).toISOString());
      fd.append('address', String(appAddress));
      fd.append('portfolio', '');
      fd.append('bio', '');
      fd.append('consent', 'true');
      fd.append('file', { uri: appValidIdImage.uri, name: 'valid_id.jpg', type: 'image/jpeg' });
      fd.append('file2', { uri: appSelfieImage.uri, name: 'selfie.jpg', type: 'image/jpeg' });

      const endpoint = ${API_BASE}/request/registerAsArtist;
      const res = await fetch(endpoint, {
        method: 'POST',
        headers: { Cookie: access_token=${at}; refresh_token=${rt} },
        body: fd,
      });
      const bodyText = await res.text();
      if (!res.ok) throw new Error(bodyText || 'Application failed');

      await checkPendingRequest(at, rt);
      Alert.alert('Submitted', 'Your application has been submitted.');
      setApplyModalVisible(false);
    } catch (e) {
      console.error('submitArtistApplication error:', e?.message || e);
      Alert.alert('Failed', e?.message || 'Could not submit application');
    } finally {
      setAppSubmitting(false);
    }
  };

  // Fetch PSGC regions when seller modal opens
  useEffect(() => {
    if (sellerModalVisible) {
      fetchRegions();
      // Pre-fill user data
      setSellerFullName(userData?.fullName || firstName + ' ' + lastName || '');
      setSellerEmail(userData?.email || '');
    }
  }, [sellerModalVisible]);

  const fetchRegions = async () => {
    try {
      const response = await fetch('https://psgc.gitlab.io/api/regions/');
      const data = await response.json();
      setRegions(data);
    } catch (error) {
      console.error('Error fetching regions:', error);
    }
  };

  const fetchProvinces = async (regionCode) => {
    try {
      const response = await fetch(https://psgc.gitlab.io/api/regions/${regionCode}/provinces/);
      const data = await response.json();
      setProvinces(data);
    } catch (error) {
      console.error('Error fetching provinces:', error);
    }
  };

  const fetchCities = async (provinceCode) => {
    try {
      const response = await fetch(https://psgc.gitlab.io/api/provinces/${provinceCode}/cities-municipalities/);
      const data = await response.json();
      setCities(data);
    } catch (error) {
      console.error('Error fetching cities:', error);
    }
  };

  const fetchBarangays = async (cityCode) => {
    try {
      const response = await fetch(https://psgc.gitlab.io/api/cities-municipalities/${cityCode}/barangays/);
      const data = await response.json();
      setBarangays(data);
    } catch (error) {
      console.error('Error fetching barangays:', error);
    }
  };

  const handleRegionChange = (regionCode) => {
    setSelectedRegion(regionCode);
    setSelectedProvince('');
    setSelectedCity('');
    setSelectedBarangay('');
    setProvinces([]);
    setCities([]);
    setBarangays([]);
    if (regionCode) {
      fetchProvinces(regionCode);
    }
    setShowRegionDropdown(false);
  };

  const handleProvinceChange = (provinceCode) => {
    setSelectedProvince(provinceCode);
    setSelectedCity('');
    setSelectedBarangay('');
    setCities([]);
    setBarangays([]);
    if (provinceCode) {
      fetchCities(provinceCode);
    }
    setShowProvinceDropdown(false);
  };

  const handleCityChange = (cityCode) => {
    setSelectedCity(cityCode);
    setSelectedBarangay('');
    setBarangays([]);
    if (cityCode) {
      fetchBarangays(cityCode);
    }
    setShowCityDropdown(false);
  };

  const handleBarangayChange = (barangayCode) => {
    setSelectedBarangay(barangayCode);
    setShowBarangayDropdown(false);
  };

  const validateSellerStep = () => {
    if (sellerCurrentStep === 1) {
      if (!shopName.trim() || !sellerFullName.trim() || !sellerEmail.trim() || !sellerPhone.trim()) {
        Alert.alert('Incomplete', 'Please fill in all required fields.');
        return false;
      }
      if (!/\S+@\S+\.\S+/.test(sellerEmail)) {
        Alert.alert('Invalid', 'Please enter a valid email address.');
        return false;
      }
    } else if (sellerCurrentStep === 2) {
      if (!street.trim() || !selectedRegion || !selectedProvince || !selectedCity || !selectedBarangay || !postalCode.trim()) {
        Alert.alert('Incomplete', 'Please complete all address fields.');
        return false;
      }
    } else if (sellerCurrentStep === 3) {
      if (!shopDescription.trim() || !sellerIdDocument) {
        Alert.alert('Incomplete', 'Please provide shop description and upload your ID.');
        return false;
      }
      if (!agreedToTerms) {
        Alert.alert('Agreement Required', 'You must agree to the Seller Terms and Conditions.');
        return false;
      }
    }
    return true;
  };

  const handleSellerNext = () => {
    if (validateSellerStep()) {
      setSellerCurrentStep(prev => prev + 1);
    }
  };

  const handleSellerBack = () => {
    setSellerCurrentStep(prev => prev - 1);
  };

  const submitSellerApplication = async () => {
    if (!validateSellerStep()) return;

    try {
      setSellerSubmitting(true);

      let at = accessToken, rt = refreshToken;
      if (!at || !rt) {
        const { data } = await supabase.auth.getSession();
        at = data?.session?.access_token || at;
        rt = data?.session?.refresh_token || rt;
      }

      const region = regions.find(r => r.code === selectedRegion);
      const province = provinces.find(p => p.code === selectedProvince);
      const city = cities.find(c => c.code === selectedCity);
      const barangay = barangays.find(b => b.code === selectedBarangay);

      const fd = new FormData();
      fd.append('shopName', shopName);
      fd.append('fullName', sellerFullName);
      fd.append('email', sellerEmail);
      fd.append('phoneNumber', sellerPhone);
      fd.append('street', street);
      fd.append('landmark', landmark);
      fd.append('region', region?.name || '');
      fd.append('province', province?.name || '');
      fd.append('city', city?.name || '');
      fd.append('barangay', barangay?.name || '');
      fd.append('postalCode', postalCode);
      fd.append('shopDescription', shopDescription);
      fd.append('idDocument', {
        uri: sellerIdDocument.uri,
        name: 'government_id.jpg',
        type: 'image/jpeg'
      });

      const endpoint = ${API_BASE}/marketplace/seller/apply;
      const res = await fetch(endpoint, {
        method: 'POST',
        headers: { Cookie: access_token=${at}; refresh_token=${rt} },
        body: fd,
      });

      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.error || 'Application failed');
      }

      const data = await res.json();
      
      // Success notification with detailed message
      Alert.alert(
        ' Application Submitted!',
        data.message || 'Your seller application has been submitted successfully!\n\nWhat happens next:\n Our team will review your application\n You\'ll be notified via email once approved\n You can check your application status in Settings\n\nThank you for joining Museo Marketplace!',
        [
          {
            text: 'OK',
            onPress: () => {
              console.log('Seller application submitted successfully');
            }
          }
        ]
      );
      
      setHasPendingSellerRequest(true);
      resetSellerForm();
      setSellerModalVisible(false);
    } catch (e) {
      console.error('submitSellerApplication error:', e?.message || e);
      Alert.alert('Failed', e?.message || 'Could not submit application');
    } finally {
      setSellerSubmitting(false);
    }
  };

  const pickSellerIdDocument = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [4, 3],
      quality: 1,
    });
    if (!result.canceled) {
      setSellerIdDocument({ uri: result.assets[0].uri });
    }
  };

  const resetSellerForm = () => {
    setSellerCurrentStep(1);
    setShopName('');
    setSellerFullName('');
    setSellerEmail('');
    setSellerPhone('');
    setStreet('');
    setLandmark('');
    setSelectedRegion('');
    setSelectedProvince('');
    setSelectedCity('');
    setSelectedBarangay('');
    setPostalCode('');
    setShopDescription('');
    setSellerIdDocument(null);
    setAgreedToTerms(false);
  };

  const formattedTempDate = tempBirthday
    ? tempBirthday.toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" })
    : "";

  return (
    <SafeAreaView style={styles.container}>
      <Header title="Settings" showSearch={false} />

      <ScrollView style={styles.scrollView} contentContainerStyle={styles.contentContainer}>
        
        {/* Profile Section */}
        <View style={styles.section}>
            <Text style={styles.sectionTitle}>Profile Settings</Text>
            
            {/* Profile Preview - Tap to View */}
            <TouchableOpacity 
              style={styles.profilePreviewCard}
              onPress={() => router.push('/profile')}
              activeOpacity={0.7}
            >
              <Image 
                source={image || { uri: 'https://via.placeholder.com/100' }} 
                style={styles.profileAvatar}
              />
              <View style={styles.profileInfo}>
                <Text style={styles.profileName}>
                  {userData?.fullName || userData?.username || 'User Name'}
                </Text>
                <Text style={styles.profileUsername}>@{userData?.username || 'username'}</Text>
                <Text style={styles.profileViewHint}>Tap to view profile</Text>
              </View>
              <Ionicons name="chevron-forward" size={24} color="#A68C7B" />
            </TouchableOpacity>

            <TouchableOpacity
              style={styles.settingButton}
              onPress={() => {
                setTempImage(image);
                setTempBackgroundImage(backgroundImage);
                setTempFirstName(firstName);
                setTempMiddleName(middleName);
                setTempLastName(lastName);
                setTempUserNameField(userNameField || username);
                setTempSex(sex);
                setTempBirthday(birthday || new Date());
                setTempAddress(address);
                setTempBio(bio);
                setTempAbout(about);
                setModalVisible(true);
              }}
            >
              <View style={styles.settingContent}>
                <View style={styles.iconContainer}>
                  <Ionicons name="create-outline" size={24} color="#A68C7B" />
                </View>
                <View style={styles.settingTextContainer}>
                  <Text style={styles.settingTitle}>Edit Profile</Text>
                  <Text style={styles.settingDescription}>Update your personal information</Text>
                </View>
                <Ionicons name="chevron-forward" size={24} color="#999" />
              </View>
            </TouchableOpacity>

            {/* Privacy Settings */}
            <Text style={styles.groupTitle}>Privacy</Text>
            
            <View>
              <View style={[styles.settingButton, styles.visibilityContainer]}>
                <View style={styles.settingContent}>
                  <View style={styles.iconContainer}>
                    <Ionicons name="eye-outline" size={24} color="#A68C7B" />
                  </View>
                  <View style={{ flex: 1 }}>
                    <Text style={styles.settingTitle}>Profile Visibility</Text>
                    <Text style={styles.settingDescription}>Control who can see your profile</Text>
                  </View>
                </View>
                
                <TouchableOpacity 
                  style={styles.visibilitySelector}
                  onPress={() => setShowVisibilityDropdown(!showVisibilityDropdown)}
                >
                  <Text style={{ color: '#A68C7B', fontSize: 14, fontWeight: '600', flex: 1 }}>
                    {profileVisibility === 'public' ? 'Public' : profileVisibility === 'followers' ? 'Followers Only' : 'Private'}
                  </Text>
                  <Ionicons name={showVisibilityDropdown ? 'chevron-up' : 'chevron-down'} size={20} color="#A68C7B" />
                </TouchableOpacity>
              </View>
              
              {showVisibilityDropdown && (
                <View style={styles.dropdownMenu}>
                <TouchableOpacity 
                  style={styles.dropdownItem}
                  onPress={() => {
                    setProfileVisibility('public');
                    setShowVisibilityDropdown(false);
                  }}
                >
                  <Ionicons name="globe-outline" size={20} color="#666" />
                  <Text style={styles.dropdownText}>Public</Text>
                  {profileVisibility === 'public' && <Ionicons name="checkmark" size={20} color="#A68C7B" />}
                </TouchableOpacity>
                <TouchableOpacity 
                  style={styles.dropdownItem}
                  onPress={() => {
                    setProfileVisibility('followers');
                    setShowVisibilityDropdown(false);
                  }}
                >
                  <Ionicons name="people-outline" size={20} color="#666" />
                  <Text style={styles.dropdownText}>Followers Only</Text>
                  {profileVisibility === 'followers' && <Ionicons name="checkmark" size={20} color="#A68C7B" />}
                </TouchableOpacity>
                <TouchableOpacity 
                  style={styles.dropdownItem}
                  onPress={() => {
                    setProfileVisibility('private');
                    setShowVisibilityDropdown(false);
                  }}
                >
                  <Ionicons name="lock-closed-outline" size={20} color="#666" />
                  <Text style={styles.dropdownText}>Private</Text>
                  {profileVisibility === 'private' && <Ionicons name="checkmark" size={20} color="#A68C7B" />}
                </TouchableOpacity>
              </View>
              )}
            </View>

            <View style={styles.settingToggleItem}>
              <View style={styles.settingTextContainer}>
                <Text style={styles.settingTitle}>Show Activity Status</Text>
                <Text style={styles.settingDescription}>Let others see when you're active</Text>
              </View>
              <TouchableOpacity 
                style={[styles.toggleSwitch, showActivityStatus && styles.toggleSwitchActive]}
                onPress={() => setShowActivityStatus(!showActivityStatus)}
                activeOpacity={0.8}
              >
                <View style={[styles.toggleThumb, showActivityStatus && styles.toggleThumbActive]} />
              </TouchableOpacity>
            </View>
        </View>

        {/* Account Section */}
        <View style={styles.section}>
            <TouchableOpacity 
              style={styles.sectionHeader}
              onPress={() => setAccountExpanded(!accountExpanded)}
              activeOpacity={0.7}
            >
              <Text style={styles.sectionTitle}>Account Settings</Text>
              <Ionicons 
                name={accountExpanded ? "chevron-up" : "chevron-down"} 
                size={24} 
                color="#A68C7B" 
              />
            </TouchableOpacity>
            
            {accountExpanded && (
              <View>
                <Text style={styles.groupTitle}>Security</Text>
            <TouchableOpacity style={styles.settingButton}>
              <View style={styles.settingContent}>
                <View style={styles.iconContainer}>
                  <Ionicons name="key-outline" size={24} color="#A68C7B" />
                </View>
                <View style={styles.settingTextContainer}>
                  <Text style={styles.settingTitle}>Change Password</Text>
                  <Text style={styles.settingDescription}>Update your account password</Text>
                </View>
                <Ionicons name="chevron-forward" size={24} color="#999" />
              </View>
            </TouchableOpacity>

            <TouchableOpacity style={styles.settingButton}>
              <View style={styles.settingContent}>
                <View style={styles.iconContainer}>
                  <Ionicons name="mail-outline" size={24} color="#A68C7B" />
                </View>
                <View style={styles.settingTextContainer}>
                  <Text style={styles.settingTitle}>Update Email</Text>
                  <Text style={styles.settingDescription}>{userData?.email || 'user@example.com'}</Text>
                </View>
                <Ionicons name="chevron-forward" size={24} color="#999" />
              </View>
            </TouchableOpacity>

            <Text style={styles.groupTitle}>Account Management</Text>
            <TouchableOpacity style={styles.settingButton}>
              <View style={styles.settingContent}>
                <View style={styles.iconContainer}>
                  <Ionicons name="trash-outline" size={24} color="#FF4444" />
                </View>
                <View style={styles.settingTextContainer}>
                  <Text style={[styles.settingTitle, { color: '#FF4444' }]}>Delete Account</Text>
                  <Text style={styles.settingDescription}>Permanently delete your account</Text>
                </View>
                <Ionicons name="chevron-forward" size={24} color="#999" />
              </View>
            </TouchableOpacity>
              </View>
            )}
        </View>

        {/* Notifications Section */}
        <View style={styles.section}>
            <TouchableOpacity 
              style={styles.sectionHeader}
              onPress={() => setNotificationsExpanded(!notificationsExpanded)}
              activeOpacity={0.7}
            >
              <Text style={styles.sectionTitle}>Notification Preferences</Text>
              <Ionicons 
                name={notificationsExpanded ? "chevron-up" : "chevron-down"} 
                size={24} 
                color="#A68C7B" 
              />
            </TouchableOpacity>
            
            {notificationsExpanded && (
              <View>
            
            <Text style={styles.groupTitle}>Email Notifications</Text>
            
            <View style={styles.settingToggleItem}>
              <View style={styles.settingTextContainer}>
                <Text style={styles.settingTitle}>Marketing Emails</Text>
                <Text style={styles.settingDescription}>Updates about new features</Text>
              </View>
              <TouchableOpacity 
                style={[styles.toggleSwitch, marketingEmails && styles.toggleSwitchActive]}
                onPress={() => setMarketingEmails(!marketingEmails)}
                activeOpacity={0.8}
              >
                <View style={[styles.toggleThumb, marketingEmails && styles.toggleThumbActive]} />
              </TouchableOpacity>
            </View>

            <View style={styles.settingToggleItem}>
              <View style={styles.settingTextContainer}>
                <Text style={styles.settingTitle}>Order Updates</Text>
                <Text style={styles.settingDescription}>Get notified about order status</Text>
              </View>
              <TouchableOpacity 
                style={[styles.toggleSwitch, orderUpdates && styles.toggleSwitchActive]}
                onPress={() => setOrderUpdates(!orderUpdates)}
                activeOpacity={0.8}
              >
                <View style={[styles.toggleThumb, orderUpdates && styles.toggleThumbActive]} />
              </TouchableOpacity>
            </View>

            <View style={styles.settingToggleItem}>
              <View style={styles.settingTextContainer}>
                <Text style={styles.settingTitle}>New Followers</Text>
                <Text style={styles.settingDescription}>When someone follows you</Text>
              </View>
              <TouchableOpacity 
                style={[styles.toggleSwitch, newFollowers && styles.toggleSwitchActive]}
                onPress={() => setNewFollowers(!newFollowers)}
                activeOpacity={0.8}
              >
                <View style={[styles.toggleThumb, newFollowers && styles.toggleThumbActive]} />
              </TouchableOpacity>
            </View>

            <View style={styles.settingToggleItem}>
              <View style={styles.settingTextContainer}>
                <Text style={styles.settingTitle}>Comments & Likes</Text>
                <Text style={styles.settingDescription}>Interactions on your posts</Text>
              </View>
              <TouchableOpacity 
                style={[styles.toggleSwitch, commentsLikes && styles.toggleSwitchActive]}
                onPress={() => setCommentsLikes(!commentsLikes)}
                activeOpacity={0.8}
              >
                <View style={[styles.toggleThumb, commentsLikes && styles.toggleThumbActive]} />
              </TouchableOpacity>
            </View>
              </View>
            )}
        </View>

        {/* Marketplace Section */}
        <View style={styles.section}>
            <TouchableOpacity 
              style={styles.sectionHeader}
              onPress={() => setMarketplaceExpanded(!marketplaceExpanded)}
              activeOpacity={0.7}
            >
              <Text style={styles.sectionTitle}>Marketplace</Text>
              <Ionicons 
                name={marketplaceExpanded ? "chevron-up" : "chevron-down"} 
                size={24} 
                color="#A68C7B" 
              />
            </TouchableOpacity>
            
            {marketplaceExpanded && (
              <View>
            
            {userData?.isSeller ? (
              <>
                <View style={styles.sellerBadge}>
                  <Ionicons name="star" size={24} color="#FFD700" />
                  <Text style={styles.sellerBadgeText}>Verified Seller</Text>
                </View>

                <Text style={styles.groupTitle}>Seller Preferences</Text>
                
                <View style={styles.settingToggleItem}>
                  <View style={styles.settingTextContainer}>
                    <Text style={styles.settingTitle}>Accept Custom Orders</Text>
                    <Text style={styles.settingDescription}>Allow custom artwork requests</Text>
                  </View>
                  <TouchableOpacity 
                    style={[styles.toggleSwitch, acceptCustomOrders && styles.toggleSwitchActive]}
                    onPress={() => setAcceptCustomOrders(!acceptCustomOrders)}
                    activeOpacity={0.8}
                  >
                    <View style={[styles.toggleThumb, acceptCustomOrders && styles.toggleThumbActive]} />
                  </TouchableOpacity>
                </View>

                <View style={styles.settingToggleItem}>
                  <View style={styles.settingTextContainer}>
                    <Text style={styles.settingTitle}>International Shipping</Text>
                    <Text style={styles.settingDescription}>Ship artwork internationally</Text>
                  </View>
                  <TouchableOpacity 
                    style={[styles.toggleSwitch, internationalShipping && styles.toggleSwitchActive]}
                    onPress={() => setInternationalShipping(!internationalShipping)}
                    activeOpacity={0.8}
                  >
                    <View style={[styles.toggleThumb, internationalShipping && styles.toggleThumbActive]} />
                  </TouchableOpacity>
                </View>

                <View style={styles.settingToggleItem}>
                  <View style={styles.settingTextContainer}>
                    <Text style={styles.settingTitle}>Vacation Mode</Text>
                    <Text style={styles.settingDescription}>Temporarily pause your store</Text>
                  </View>
                  <TouchableOpacity 
                    style={[styles.toggleSwitch, vacationMode && styles.toggleSwitchActive]}
                    onPress={() => setVacationMode(!vacationMode)}
                    activeOpacity={0.8}
                  >
                    <View style={[styles.toggleThumb, vacationMode && styles.toggleThumbActive]} />
                  </TouchableOpacity>
                </View>
              </>
            ) : (
              <>
                {/* Apply as Artist Section */}
                {String(role ?? '').trim().toLowerCase() === 'user' && (
                  <View>
                    <Text style={styles.groupTitle}>Become an Artist</Text>
                    <TouchableOpacity
                      style={[styles.settingButton, hasPendingRequest && styles.disabledButton]}
                      onPress={() => {
                        setAppFirstName(firstName || "");
                        setAppMiddleInitial((middleName || "").slice(0,1).toUpperCase());
                        setAppLastName(lastName || "");
                        setAppSex(sex || "");
                        setAppBirthdate(birthday || new Date());
                        setAppAddress(address || "");
                        setAppPhone("");
                        setAppAge("");
                        setAppValidIdImage(null);
                        setAppSelfieImage(null);
                        setApplyModalVisible(true);
                      }}
                      disabled={hasPendingRequest}
                    >
                      <View style={styles.settingContent}>
                        <View style={styles.iconContainer}>
                          <Ionicons name="brush-outline" size={24} color={hasPendingRequest ? "#999" : "#A68C7B"} />
                        </View>
                        <View style={styles.settingTextContainer}>
                          <Text style={[styles.settingTitle, hasPendingRequest && styles.disabledText]}>
                            {hasPendingRequest ? "Verification Pending" : "Apply as Artist"}
                          </Text>
                          <Text style={styles.settingDescription}>
                            {hasPendingRequest ? "Your application is under review" : "Submit your artist verification"}
                          </Text>
                        </View>
                        {!hasPendingRequest && <Ionicons name="chevron-forward" size={24} color="#999" />}
                        {hasPendingRequest && <Ionicons name="time-outline" size={24} color="#FFC107" />}
                      </View>
                    </TouchableOpacity>
                  </View>
                )}

                {/* Apply as Seller - for Artists (only show if NOT already a seller) */}
                {String(role ?? '').trim().toLowerCase() === 'artist' && !userData?.isSeller && (
                  <View>
                    <Text style={styles.groupTitle}>Become a Seller</Text>
                    <TouchableOpacity 
                      style={[styles.settingButton, (hasPendingSellerRequest || sellerApplicationStatus === 'pending') && styles.disabledButton]}
                      onPress={() => {
                        resetSellerForm();
                        setSellerModalVisible(true);
                      }}
                      disabled={hasPendingSellerRequest || sellerApplicationStatus === 'pending'}
                    >
                      <View style={styles.settingContent}>
                        <View style={styles.iconContainer}>
                          <Ionicons 
                            name="storefront-outline" 
                            size={24} 
                            color={(hasPendingSellerRequest || sellerApplicationStatus === 'pending') ? "#999" : sellerApplicationStatus === 'rejected' ? "#FF4444" : "#A68C7B"} 
                          />
                        </View>
                        <View style={styles.settingTextContainer}>
                          <Text style={[styles.settingTitle, (hasPendingSellerRequest || sellerApplicationStatus === 'pending') && styles.disabledText, sellerApplicationStatus === 'rejected' && { color: '#FF4444' }]}>
                            {sellerApplicationStatus === 'pending' || hasPendingSellerRequest ? "Seller Verification Pending" : 
                             sellerApplicationStatus === 'rejected' ? "Application Rejected - Reapply" : 
                             "Apply as Seller"}
                          </Text>
                          <Text style={styles.settingDescription}>
                            {sellerApplicationStatus === 'pending' || hasPendingSellerRequest ? "Your seller application is under review" : 
                             sellerApplicationStatus === 'rejected' ? "Your application was rejected. You can submit a new application." : 
                             "Register to sell your artwork"}
                          </Text>
                        </View>
                        {!hasPendingSellerRequest && sellerApplicationStatus !== 'pending' && sellerApplicationStatus !== 'rejected' && <Ionicons name="chevron-forward" size={24} color="#999" />}
                        {(hasPendingSellerRequest || sellerApplicationStatus === 'pending') && <Ionicons name="time-outline" size={24} color="#FFC107" />}
                        {sellerApplicationStatus === 'rejected' && <Ionicons name="refresh" size={24} color="#FF4444" />}
                      </View>
                    </TouchableOpacity>
                  </View>
                )}
              </>
            )}
              </View>
            )}
        </View>
      </ScrollView>

      {/* Edit Profile Modal */}
      <Modal visible={modalVisible} animationType="slide" transparent onRequestClose={() => setModalVisible(false)}>
        <KeyboardAvoidingView 
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <View style={styles.uploadModalOverlay}>
            <View style={styles.uploadModalContent}>
              <View style={styles.uploadModalHeader}>
                <Text style={styles.uploadModalTitle}>Edit Profile</Text>
                <TouchableOpacity onPress={() => setModalVisible(false)}>
                  <Ionicons name="close" size={24} color="#333" />
                </TouchableOpacity>
              </View>

              <ScrollView style={styles.uploadModalBody} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
                <Text style={styles.uploadInputLabel}>Profile Photo</Text>
                <TouchableOpacity onPress={pickImage} style={styles.uploadImagePicker}>
                  {tempImage ? (
                    <Image source={tempImage} style={styles.uploadPickedImage} />
                  ) : (
                    <View style={styles.uploadImagePlaceholder}>
                      <Ionicons name="person-circle-outline" size={48} color="#A68C7B" />
                      <Text style={styles.uploadImageText}>Tap to change photo</Text>
                    </View>
                  )}
                </TouchableOpacity>

                <Text style={styles.uploadInputLabel}>Cover Photo</Text>
                <TouchableOpacity onPress={pickBackgroundImage} style={styles.uploadImagePicker}>
                  {tempBackgroundImage ? (
                    <Image source={{ uri: tempBackgroundImage.uri }} style={styles.uploadPickedImage} />
                  ) : (
                    <View style={styles.uploadImagePlaceholder}>
                      <Ionicons name="image-outline" size={48} color="#A68C7B" />
                      <Text style={styles.uploadImageText}>Tap to change cover</Text>
                    </View>
                  )}
                </TouchableOpacity>

                <Text style={styles.uploadInputLabel}>First Name</Text>
                <TextInput style={styles.uploadInput} placeholder="First Name" value={tempFirstName} onChangeText={setTempFirstName} />

                <Text style={styles.uploadInputLabel}>Middle Name</Text>
                <TextInput style={styles.uploadInput} placeholder="Middle Name" value={tempMiddleName} onChangeText={setTempMiddleName} />

                <Text style={styles.uploadInputLabel}>Last Name</Text>
                <TextInput style={styles.uploadInput} placeholder="Last Name" value={tempLastName} onChangeText={setTempLastName} />

                <Text style={styles.uploadInputLabel}>Username</Text>
                <TextInput style={styles.uploadInput} placeholder="Username" value={tempUserNameField} onChangeText={setTempUserNameField} />

                <Text style={styles.uploadInputLabel}>Sex</Text>
                <TouchableOpacity style={styles.uploadInput} onPress={() => setShowSexDropdown(!showSexDropdown)}>
                  <Text style={{ color: tempSex ? "#000" : "#999" }}>{tempSex || "Select Sex"}</Text>
                  <Ionicons name={showSexDropdown ? "chevron-up" : "chevron-down"} size={20} color="#555" style={{ position: "absolute", right: 12, top: 12 }} />
                </TouchableOpacity>
                {showSexDropdown && (
                  <View style={styles.categoryDropdown}>
                    {["Male", "Female", "PreferNotToSay"].map((item) => (
                      <TouchableOpacity key={item} style={styles.categoryItem} onPress={() => { setTempSex(item); setShowSexDropdown(false); }}>
                        <Text style={styles.categoryItemText}>{item}</Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}

                <Text style={styles.uploadInputLabel}>Birthday</Text>
                <TouchableOpacity style={styles.uploadInput} onPress={() => setShowDatePicker(true)}>
                  <Text style={{ color: tempBirthday ? "#000" : "#999" }}>
                    {tempBirthday ? formattedTempDate : "Select your birthday"}
                  </Text>
                </TouchableOpacity>
                {showDatePicker && (
                  <DateTimePicker value={tempBirthday} mode="date" display="default" onChange={onChangeTempDate} />
                )}

                <Text style={styles.uploadInputLabel}>Address</Text>
                <TextInput style={styles.uploadInput} placeholder="Enter your address" value={tempAddress} onChangeText={setTempAddress} />

                <Text style={styles.uploadInputLabel}>Bio</Text>
                <TextInput style={styles.uploadInput} placeholder="Enter your bio" value={tempBio} onChangeText={setTempBio} />

                <Text style={styles.uploadInputLabel}>About</Text>
                <TextInput style={[styles.uploadInput, styles.uploadTextArea]} placeholder="Write something about yourself" multiline value={tempAbout} onChangeText={setTempAbout} />

                <TouchableOpacity style={styles.uploadButton} onPress={handleSave}>
                  <Text style={styles.uploadButtonText}>Save Changes</Text>
                </TouchableOpacity>
              </ScrollView>
            </View>
          </View>
        </KeyboardAvoidingView>
      </Modal>

      {/* Apply as Artist Modal */}
      <Modal
        visible={applyModalVisible}
        animationType="slide"
        transparent
        onRequestClose={() => setApplyModalVisible(false)}
      >
        <KeyboardAvoidingView 
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <View style={styles.uploadModalOverlay}>
            <View style={styles.uploadModalContent}>
              <View style={styles.uploadModalHeader}>
                <Text style={styles.uploadModalTitle}>Apply as Artist</Text>
                <TouchableOpacity onPress={() => setApplyModalVisible(false)}>
                  <Ionicons name="close" size={24} color="#333" />
                </TouchableOpacity>
              </View>

              <ScrollView style={styles.uploadModalBody} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">

                <Text style={styles.uploadInputLabel}>First Name *</Text>
                <TextInput style={styles.uploadInput} placeholder="First Name" value={appFirstName} onChangeText={setAppFirstName} />
                
                <Text style={styles.uploadInputLabel}>Middle Initial</Text>
                <TextInput style={styles.uploadInput} placeholder="Middle Initial" value={appMiddleInitial} onChangeText={setAppMiddleInitial} maxLength={1} />
                
                <Text style={styles.uploadInputLabel}>Last Name *</Text>
                <TextInput style={styles.uploadInput} placeholder="Last Name" value={appLastName} onChangeText={setAppLastName} />
                
                <Text style={styles.uploadInputLabel}>Phone Number *</Text>
                <TextInput style={styles.uploadInput} placeholder="Phone Number" keyboardType="phone-pad" value={appPhone} onChangeText={setAppPhone} />
                
                <Text style={styles.uploadInputLabel}>Age *</Text>
                <TextInput style={styles.uploadInput} placeholder="Age" keyboardType="numeric" value={appAge} onChangeText={setAppAge} />

                <Text style={styles.uploadInputLabel}>Sex *</Text>
                <TouchableOpacity style={styles.uploadInput} onPress={() => setAppShowSexDropdown(!appShowSexDropdown)}>
                  <Text style={{ color: appSex ? '#000' : '#999' }}>{appSex || 'Select Sex'}</Text>
                  <Ionicons name={appShowSexDropdown ? 'chevron-up' : 'chevron-down'} size={20} color="#555" style={{ position: 'absolute', right: 12, top: 12 }} />
                </TouchableOpacity>
                {appShowSexDropdown && (
                  <View style={styles.categoryDropdown}>
                    {['Male', 'Female', 'PreferNotToSay'].map(item => (
                      <TouchableOpacity key={item} style={styles.categoryItem} onPress={() => { setAppSex(item); setAppShowSexDropdown(false); }}>
                        <Text style={styles.categoryItemText}>{item}</Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}

                <Text style={styles.uploadInputLabel}>Birthdate *</Text>
                <TouchableOpacity style={styles.uploadInput} onPress={() => setAppShowDatePicker(true)}>
                  <Text style={{ color: appBirthdate ? '#000' : '#999' }}>
                    {appBirthdate ? appBirthdate.toLocaleDateString('en-US') : 'Select your birthdate'}
                  </Text>
                </TouchableOpacity>
                {appShowDatePicker && (
                  <DateTimePicker value={appBirthdate} mode="date" display="default" onChange={onChangeAppDate} />
                )}

                <Text style={styles.uploadInputLabel}>Address *</Text>
                <TextInput style={styles.uploadInput} placeholder="Address" value={appAddress} onChangeText={setAppAddress} />

                <Text style={styles.uploadInputLabel}>Valid ID *</Text>
                <TouchableOpacity onPress={pickValidIdImage} style={styles.uploadImagePicker}>
                  {appValidIdImage ? (
                    <Image source={appValidIdImage} style={styles.uploadPickedImage} />
                  ) : (
                    <View style={styles.uploadImagePlaceholder}>
                      <Ionicons name="card-outline" size={48} color="#A68C7B" />
                      <Text style={styles.uploadImageText}>Tap to upload Valid ID</Text>
                    </View>
                  )}
                </TouchableOpacity>

                <Text style={styles.uploadInputLabel}>Selfie *</Text>
                <TouchableOpacity onPress={pickSelfieImage} style={styles.uploadImagePicker}>
                  {appSelfieImage ? (
                    <Image source={appSelfieImage} style={styles.uploadPickedImage} />
                  ) : (
                    <View style={styles.uploadImagePlaceholder}>
                      <Ionicons name="person-outline" size={48} color="#A68C7B" />
                      <Text style={styles.uploadImageText}>Tap to upload Selfie</Text>
                    </View>
                  )}
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.uploadButton, appSubmitting && styles.uploadButtonDisabled]}
                  onPress={submitArtistApplication}
                  disabled={appSubmitting}
                >
                  <Text style={styles.uploadButtonText}>
                    {appSubmitting ? 'Submitting...' : 'Submit Application'}
                  </Text>
                </TouchableOpacity>
              </ScrollView>
            </View>
          </View>
        </KeyboardAvoidingView>
      </Modal>

      {/* Apply as Seller Modal - 3 Steps */}
      <Modal
        visible={sellerModalVisible}
        animationType="slide"
        transparent
        onRequestClose={() => {
          resetSellerForm();
          setSellerModalVisible(false);
        }}
      >
        <KeyboardAvoidingView 
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <View style={styles.uploadModalOverlay}>
            <View style={styles.uploadModalContent}>
              <View style={styles.uploadModalHeader}>
                <View>
                  <Text style={styles.uploadModalTitle}>Become a Museo Seller</Text>
                  <Text style={{ fontSize: 13, color: '#666', marginTop: 4 }}>
                    Step {sellerCurrentStep} of 3 - {sellerCurrentStep === 1 ? 'Basic Information' : sellerCurrentStep === 2 ? 'Business Address' : 'Verification'}
                  </Text>
                </View>
                <TouchableOpacity onPress={() => { resetSellerForm(); setSellerModalVisible(false); }}>
                  <Ionicons name="close" size={24} color="#333" />
                </TouchableOpacity>
              </View>

              {/* Progress Bar */}
              <View style={{ flexDirection: 'row', gap: 4, paddingHorizontal: 20, marginBottom: 20 }}>
                {[1, 2, 3].map(step => (
                  <View key={step} style={{
                    flex: 1,
                    height: 4,
                    backgroundColor: step <= sellerCurrentStep ? '#A68C7B' : '#e0e0e0',
                    borderRadius: 2
                  }} />
                ))}
              </View>

              <ScrollView style={styles.uploadModalBody} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">

                {/* Step 1: Basic Information */}
                {sellerCurrentStep === 1 && (
                  <View>
                    <View style={{ padding: 12, backgroundColor: '#FFF9E6', borderRadius: 8, marginBottom: 20, borderLeftWidth: 4, borderLeftColor: '#A68C7B' }}>
                      <Text style={{ fontSize: 13, color: '#666' }}>
                        <Text style={{ fontWeight: 'bold' }}>Welcome!</Text> Start selling your artwork on Museo. No business registration required for individual artists.
                      </Text>
                    </View>

                    <Text style={styles.uploadInputLabel}>Shop Name *</Text>
                    <TextInput 
                      style={styles.uploadInput} 
                      placeholder="e.g., Aria's Art Studio"
                      value={shopName} 
                      onChangeText={setShopName} 
                    />
                    <Text style={{ fontSize: 12, color: '#999', marginBottom: 16, marginTop: -8 }}>This will be your public seller name on Museo</Text>

                    <Text style={styles.uploadInputLabel}>Full Name *</Text>
                    <TextInput 
                      style={styles.uploadInput} 
                      placeholder="Juan Dela Cruz"
                      value={sellerFullName} 
                      onChangeText={setSellerFullName} 
                    />

                    <Text style={styles.uploadInputLabel}>Email *</Text>
                    <TextInput 
                      style={styles.uploadInput} 
                      placeholder="your@email.com"
                      keyboardType="email-address"
                      value={sellerEmail} 
                      onChangeText={setSellerEmail} 
                    />

                    <Text style={styles.uploadInputLabel}>Phone Number *</Text>
                    <TextInput 
                      style={styles.uploadInput} 
                      placeholder="+63 912 345 6789"
                      keyboardType="phone-pad"
                      value={sellerPhone} 
                      onChangeText={setSellerPhone} 
                    />
                  </View>
                )}

                {/* Step 2: Business Address */}
                {sellerCurrentStep === 2 && (
                  <View>
                    <View style={{ padding: 12, backgroundColor: '#FFF9E6', borderRadius: 8, marginBottom: 20, borderLeftWidth: 4, borderLeftColor: '#A68C7B' }}>
                      <Text style={{ fontSize: 13, color: '#666' }}>
                        <Text style={{ fontWeight: 'bold' }}>Business Address</Text> - This will be used for returns and verification purposes.
                      </Text>
                    </View>

                    <Text style={styles.uploadInputLabel}>Street Address *</Text>
                    <TextInput 
                      style={styles.uploadInput} 
                      placeholder="House/Unit No., Building, Street"
                      value={street} 
                      onChangeText={setStreet} 
                    />

                    <Text style={styles.uploadInputLabel}>Landmark (Optional)</Text>
                    <TextInput 
                      style={styles.uploadInput} 
                      placeholder="Near..."
                      value={landmark} 
                      onChangeText={setLandmark} 
                    />

                    <Text style={styles.uploadInputLabel}>Region *</Text>
                    <TouchableOpacity style={styles.uploadInput} onPress={() => setShowRegionDropdown(!showRegionDropdown)}>
                      <Text style={{ color: selectedRegion ? '#000' : '#999' }}>
                        {selectedRegion ? regions.find(r => r.code === selectedRegion)?.name : 'Select Region'}
                      </Text>
                      <Ionicons name={showRegionDropdown ? 'chevron-up' : 'chevron-down'} size={20} color="#555" style={{ position: 'absolute', right: 12, top: 12 }} />
                    </TouchableOpacity>
                    {showRegionDropdown && (
                      <View style={[styles.categoryDropdown, { maxHeight: 200 }]}>
                        <ScrollView nestedScrollEnabled={true} showsVerticalScrollIndicator={true}>
                          {regions.map(region => (
                            <TouchableOpacity key={region.code} style={styles.categoryItem} onPress={() => handleRegionChange(region.code)}>
                              <Text style={styles.categoryItemText}>{region.name}</Text>
                            </TouchableOpacity>
                          ))}
                        </ScrollView>
                      </View>
                    )}

                    <Text style={styles.uploadInputLabel}>Province *</Text>
                    <TouchableOpacity 
                      style={[styles.uploadInput, { opacity: !selectedRegion ? 0.5 : 1 }]} 
                      onPress={() => selectedRegion && setShowProvinceDropdown(!showProvinceDropdown)}
                      disabled={!selectedRegion}
                    >
                      <Text style={{ color: selectedProvince ? '#000' : '#999' }}>
                        {selectedProvince ? provinces.find(p => p.code === selectedProvince)?.name : 'Select Province'}
                      </Text>
                      <Ionicons name={showProvinceDropdown ? 'chevron-up' : 'chevron-down'} size={20} color="#555" style={{ position: 'absolute', right: 12, top: 12 }} />
                    </TouchableOpacity>
                    {showProvinceDropdown && (
                      <View style={[styles.categoryDropdown, { maxHeight: 200 }]}>
                        <ScrollView nestedScrollEnabled={true} showsVerticalScrollIndicator={true}>
                          {provinces.map(province => (
                            <TouchableOpacity key={province.code} style={styles.categoryItem} onPress={() => handleProvinceChange(province.code)}>
                              <Text style={styles.categoryItemText}>{province.name}</Text>
                            </TouchableOpacity>
                          ))}
                        </ScrollView>
                      </View>
                    )}

                    <Text style={styles.uploadInputLabel}>City/Municipality *</Text>
                    <TouchableOpacity 
                      style={[styles.uploadInput, { opacity: !selectedProvince ? 0.5 : 1 }]} 
                      onPress={() => selectedProvince && setShowCityDropdown(!showCityDropdown)}
                      disabled={!selectedProvince}
                    >
                      <Text style={{ color: selectedCity ? '#000' : '#999' }}>
                        {selectedCity ? cities.find(c => c.code === selectedCity)?.name : 'Select City/Municipality'}
                      </Text>
                      <Ionicons name={showCityDropdown ? 'chevron-up' : 'chevron-down'} size={20} color="#555" style={{ position: 'absolute', right: 12, top: 12 }} />
                    </TouchableOpacity>
                    {showCityDropdown && (
                      <View style={[styles.categoryDropdown, { maxHeight: 200 }]}>
                        <ScrollView nestedScrollEnabled={true} showsVerticalScrollIndicator={true}>
                          {cities.map(city => (
                            <TouchableOpacity key={city.code} style={styles.categoryItem} onPress={() => handleCityChange(city.code)}>
                              <Text style={styles.categoryItemText}>{city.name}</Text>
                            </TouchableOpacity>
                          ))}
                        </ScrollView>
                      </View>
                    )}

                    <Text style={styles.uploadInputLabel}>Barangay *</Text>
                    <TouchableOpacity 
                      style={[styles.uploadInput, { opacity: !selectedCity ? 0.5 : 1 }]} 
                      onPress={() => selectedCity && setShowBarangayDropdown(!showBarangayDropdown)}
                      disabled={!selectedCity}
                    >
                      <Text style={{ color: selectedBarangay ? '#000' : '#999' }}>
                        {selectedBarangay ? barangays.find(b => b.code === selectedBarangay)?.name : 'Select Barangay'}
                      </Text>
                      <Ionicons name={showBarangayDropdown ? 'chevron-up' : 'chevron-down'} size={20} color="#555" style={{ position: 'absolute', right: 12, top: 12 }} />
                    </TouchableOpacity>
                    {showBarangayDropdown && (
                      <View style={[styles.categoryDropdown, { maxHeight: 200 }]}>
                        <ScrollView nestedScrollEnabled={true} showsVerticalScrollIndicator={true}>
                          {barangays.map(barangay => (
                            <TouchableOpacity key={barangay.code} style={styles.categoryItem} onPress={() => handleBarangayChange(barangay.code)}>
                              <Text style={styles.categoryItemText}>{barangay.name}</Text>
                            </TouchableOpacity>
                          ))}
                        </ScrollView>
                      </View>
                    )}

                    <Text style={styles.uploadInputLabel}>Postal Code *</Text>
                    <TextInput 
                      style={styles.uploadInput} 
                      placeholder="1234"
                      keyboardType="number-pad"
                      maxLength={4}
                      value={postalCode} 
                      onChangeText={setPostalCode} 
                    />
                  </View>
                )}

                {/* Step 3: Verification & Terms */}
                {sellerCurrentStep === 3 && (
                  <View>
                    <View style={{ padding: 12, backgroundColor: '#FFF9E6', borderRadius: 8, marginBottom: 20, borderLeftWidth: 4, borderLeftColor: '#A68C7B' }}>
                      <Text style={{ fontSize: 13, color: '#666' }}>
                        <Text style={{ fontWeight: 'bold' }}>Final Step!</Text> Upload your ID and agree to our seller terms.
                      </Text>
                    </View>

                    <Text style={styles.uploadInputLabel}>Shop Description *</Text>
                    <TextInput 
                      style={[styles.uploadInput, styles.uploadTextArea]} 
                      placeholder="Tell buyers about your art style, inspiration, and what makes your work unique..."
                      multiline
                      numberOfLines={4}
                      value={shopDescription} 
                      onChangeText={setShopDescription} 
                    />

                    <Text style={styles.uploadInputLabel}>Government ID (for verification) *</Text>
                    <TouchableOpacity onPress={pickSellerIdDocument} style={styles.uploadImagePicker}>
                      {sellerIdDocument ? (
                        <Image source={sellerIdDocument} style={styles.uploadPickedImage} />
                      ) : (
                        <View style={styles.uploadImagePlaceholder}>
                          <Ionicons name="card-outline" size={48} color="#A68C7B" />
                          <Text style={styles.uploadImageText}>Upload valid government ID</Text>
                          <Text style={{ fontSize: 12, color: '#999', marginTop: 4 }}>JPG, PNG up to 10MB</Text>
                        </View>
                      )}
                    </TouchableOpacity>

                    {/* Seller Agreement */}
                    <View style={{ padding: 12, backgroundColor: '#f5f5f5', borderRadius: 8, maxHeight: 200, marginBottom: 16 }}>
                      <Text style={{ fontSize: 14, fontWeight: 'bold', color: '#A68C7B', marginBottom: 8 }}>Seller Agreement</Text>
                      <ScrollView style={{ maxHeight: 140 }}>
                        <Text style={{ fontSize: 13, color: '#666', lineHeight: 20 }}>
                           15% commission on all sales{'\n'}
                           Provide accurate artwork descriptions{'\n'}
                           Ship within specified timeframe{'\n'}
                           Respond to inquiries within 2-3 business days{'\n'}
                           Honor returns for damaged items{'\n'}
                           No counterfeit or stolen artwork{'\n'}
                           Maintain professional conduct{'\n'}
                           Payments processed within 7-10 days after delivery{'\n'}
                           You own rights to artwork sold{'\n'}
                           Museo may remove listings that violate policies
                        </Text>
                      </ScrollView>
                    </View>

                    <TouchableOpacity 
                      style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 20 }}
                      onPress={() => setAgreedToTerms(!agreedToTerms)}
                    >
                      <View style={{
                        width: 20,
                        height: 20,
                        borderRadius: 4,
                        borderWidth: 2,
                        borderColor: agreedToTerms ? '#A68C7B' : '#ccc',
                        backgroundColor: agreedToTerms ? '#A68C7B' : '#fff',
                        marginRight: 8,
                        justifyContent: 'center',
                        alignItems: 'center'
                      }}>
                        {agreedToTerms && <Ionicons name="checkmark" size={16} color="#fff" />}
                      </View>
                      <Text style={{ fontSize: 14, color: '#333' }}>I agree to the Seller Terms and Conditions *</Text>
                    </TouchableOpacity>
                  </View>
                )}

                {/* Navigation Buttons */}
                <View style={{ flexDirection: 'row', gap: 10, marginTop: 20, paddingBottom: 20 }}>
                  {sellerCurrentStep > 1 && (
                    <TouchableOpacity 
                      style={[styles.uploadButton, { backgroundColor: '#e0e0e0', flex: 1 }]}
                      onPress={handleSellerBack}
                      disabled={sellerSubmitting}
                    >
                      <Text style={[styles.uploadButtonText, { color: '#333' }]}>Back</Text>
                    </TouchableOpacity>
                  )}

                  {sellerCurrentStep < 3 ? (
                    <TouchableOpacity 
                      style={[styles.uploadButton, { flex: 1 }]}
                      onPress={handleSellerNext}
                      disabled={sellerSubmitting}
                    >
                      <Text style={styles.uploadButtonText}>Next</Text>
                    </TouchableOpacity>
                  ) : (
                    <TouchableOpacity 
                      style={[styles.uploadButton, { flex: 1, opacity: (!agreedToTerms || sellerSubmitting) ? 0.5 : 1 }]}
                      onPress={submitSellerApplication}
                      disabled={!agreedToTerms || sellerSubmitting}
                    >
                      <Text style={styles.uploadButtonText}>
                        {sellerSubmitting ? 'Submitting...' : 'Submit Application'}
                      </Text>
                    </TouchableOpacity>
                  )}
                </View>
              </ScrollView>
            </View>
          </View>
        </KeyboardAvoidingView>
      </Modal>
      <AndroidFooterSpacer />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#fff" },
  scrollView: { flex: 1 },
  contentContainer: { padding: 20 },
  title: { fontSize: 28, fontWeight: "bold", color: "#A68C7B", marginBottom: 30 },
  section: { marginBottom: 15 },
  settingButton: {
    backgroundColor: "#fff",
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  settingContent: { flexDirection: "row", alignItems: "center" },
  iconContainer: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: "#F5F0EB",
    justifyContent: "center",
    alignItems: "center",
    marginRight: 16,
  },
  settingTextContainer: { flex: 1 },
  settingTitle: { fontSize: 16, fontWeight: "600", color: "#333", marginBottom: 4 },
  settingDescription: { fontSize: 13, color: "#666" },
  disabledButton: { opacity: 0.6 },
  disabledText: { color: "#999" },
  uploadModalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'flex-end',
  },
  uploadModalContent: {
    backgroundColor: '#fff',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    maxHeight: '90%',
  },
  uploadModalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  uploadModalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#A68C7B',
  },
  uploadModalBody: {
    padding: 20,
  },
  uploadImagePicker: {
    width: '100%',
    height: 200,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: '#A68C7B',
    borderStyle: 'dashed',
    marginBottom: 20,
    overflow: 'hidden',
  },
  uploadImagePlaceholder: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f9f9f9',
  },
  uploadImageText: {
    marginTop: 10,
    fontSize: 14,
    color: '#A68C7B',
  },
  uploadPickedImage: {
    width: '100%',
    height: '100%',
    resizeMode: 'cover',
  },
  uploadInputLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  uploadInput: {
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 8,
    padding: 12,
    fontSize: 14,
    marginBottom: 16,
    backgroundColor: '#fff',
  },
  uploadTextArea: {
    height: 100,
    textAlignVertical: 'top',
  },
  uploadButton: {
    backgroundColor: '#A68C7B',
    paddingVertical: 15,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 10,
    marginBottom: 20,
  },
  uploadButtonDisabled: {
    opacity: 0.6,
  },
  uploadButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  categoryDropdown: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 8,
    marginTop: -8,
    marginBottom: 16,
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  categoryItem: {
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  categoryItemText: {
    fontSize: 14,
    color: '#333',
  },
  // Tab styles
  tabContainer: {
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  tabContentContainer: {
    paddingHorizontal: 15,
    paddingVertical: 10,
  },
  tabButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    marginRight: 8,
    borderRadius: 20,
    backgroundColor: '#f5f5f5',
  },
  tabButtonActive: {
    backgroundColor: '#F5F0EB',
  },
  tabButtonText: {
    fontSize: 14,
    color: '#999',
    marginLeft: 6,
    fontWeight: '500',
  },
  tabButtonTextActive: {
    color: '#A68C7B',
    fontWeight: '600',
  },
  // Tab panels
  tabPanel: {
    marginBottom: 20,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#A68C7B',
  },
  groupTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginTop: 20,
    marginBottom: 12,
  },
  // Profile preview
  profilePreviewCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    flexDirection: 'row',
    alignItems: 'center',
  },
  profileAvatar: {
    width: 60,
    height: 60,
    borderRadius: 30,
    marginRight: 16,
  },
  profileInfo: {
    flex: 1,
  },
  profileName: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 4,
  },
  profileUsername: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  profileViewHint: {
    fontSize: 12,
    color: '#A68C7B',
    fontStyle: 'italic',
  },
  // Toggle items
  settingToggleItem: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    flexDirection: 'row',
    alignItems: 'center',
  },
  // Seller badge
  sellerBadge: {
    backgroundColor: '#FFF9E6',
    borderRadius: 12,
    padding: 16,
    marginBottom: 20,
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#FFD700',
  },
  sellerBadgeText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginLeft: 10,
  },
  // Activities
  activitiesHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  activitiesLoading: {
    padding: 40,
    alignItems: 'center',
  },
  loadingText: {
    fontSize: 14,
    color: '#666',
  },
  activitiesList: {
    marginTop: 10,
  },
  activityCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    flexDirection: 'row',
    alignItems: 'center',
  },
  activityEmoji: {
    fontSize: 32,
    marginRight: 16,
  },
  activityContent: {
    flex: 1,
  },
  activityText: {
    fontSize: 14,
    color: '#333',
    marginBottom: 4,
  },
  activityTime: {
    fontSize: 12,
    color: '#999',
  },
  activitiesEmpty: {
    alignItems: 'center',
    padding: 40,
  },
  emptyTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginTop: 16,
    marginBottom: 8,
  },
  emptyDescription: {
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
    marginBottom: 20,
  },
  primaryButton: {
    backgroundColor: '#A68C7B',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
  },
  primaryButtonText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '600',
  },
  // Toggle Switch Styles
  toggleSwitch: {
    width: 51,
    height: 31,
    borderRadius: 16,
    backgroundColor: '#E0E0E0',
    justifyContent: 'center',
    padding: 2,
  },
  toggleSwitchActive: {
    backgroundColor: '#A68C7B',
  },
  toggleThumb: {
    width: 27,
    height: 27,
    borderRadius: 14,
    backgroundColor: '#fff',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 3,
  },
  toggleThumbActive: {
    alignSelf: 'flex-end',
  },
  // Profile Visibility Dropdown
  visibilityContainer: {
    paddingVertical: 20,
    paddingHorizontal: 20,
    flexDirection: 'column',
  },
  visibilitySelector: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
    backgroundColor: '#F5F0EB',
    marginTop: 12,
    width: '100%',
  },
  dropdownMenu: {
    backgroundColor: '#fff',
    borderRadius: 8,
    marginTop: 4,
    marginBottom: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  dropdownItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  dropdownText: {
    flex: 1,
    fontSize: 14,
    color: '#333',
    marginLeft: 12,
  },
});

That two code is working when I click it edit where it saved what already save and it can but right now I modify my profile.js where I transfer the modal to my profile.js 

I provided that 2 code because that 2 code is perfect when I did not transfer the modal in profile to profileModal

So you can use only reference or use it as logic what happen there


So what you will update only is my settings.js nothing in order for edit to work again in my code right now
